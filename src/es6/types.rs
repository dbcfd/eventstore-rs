use bytes::Bytes;
use std::cmp::Ordering;
use std::collections::HashMap;
use crate::types;
use uuid::Uuid;
use serde::de::Deserialize;
use serde::ser::Serialize;

/// Constants used for expected version control.
/// The use of expected version can be a bit tricky especially when discussing
/// assurances given by the GetEventStore server.
///
/// The GetEventStore server will assure idempotency for all operations using
/// any value in `ExpectedVersion` except `ExpectedVersion::Any`. When using
/// `ExpectedVersion::Any`, the GetEventStore server will do its best to assure
/// idempotency but will not guarantee idempotency.
#[derive(Copy, Clone, Debug)]
pub enum ExpectedVersion {
    /// This write should not conflict with anything and should always succeed.
    Any,

    /// The stream should exist. If it or a metadata stream does not exist,
    /// treats that as a concurrency problem.
    StreamExists,

    /// The stream being written to should not yet exist. If it does exist,
    /// treats that as a concurrency problem.
    NoStream,

    /// States that the last event written to the stream should have an event
    /// number matching your expected value.
    Exact(u64),
}

/// Holds data of event about to be sent to the server.
pub struct EventData {
    pub(crate) event_type: String,
    pub(crate) payload: types::Payload,
    pub(crate) id_opt: Option<Uuid>,
    pub(crate) custom_metadata: Option<types::Payload>,
}

impl EventData {
    /// Creates an event with a JSON payload.
    pub fn json<P, S>(event_type: String, payload: P) -> serde_json::Result<EventData>
    where
        P: Serialize,
    {
        let payload = serde_json::to_vec(&payload)?;
        let payload = Bytes::from(payload);
        let payload = types::Payload::Json(payload);

        Ok(EventData {
            event_type,
            payload,
            id_opt: None,
            custom_metadata: None,
        })
    }

    /// Creates an event with a raw binary payload.
    pub fn binary<S>(event_type: String, payload: Bytes) -> Self {
        EventData {
            event_type,
            payload: types::Payload::Binary(payload),
            id_opt: None,
            custom_metadata: None,
        }
    }

    /// Set an id to this event. By default, the id will be generated by the
    /// server.
    pub fn id(self, value: Uuid) -> Self {
        EventData {
            id_opt: Some(value),
            ..self
        }
    }

    /// Assignes a JSON metadata to this event.
    pub fn metadata_as_json<P>(self, payload: P) -> EventData
        where
            P: Serialize,
    {
        let bytes = Bytes::from(serde_json::to_vec(&payload).unwrap());
        let json_bin = Some(types::Payload::Json(bytes));

        EventData {
            custom_metadata: json_bin,
            ..self
        }
    }

    /// Assignes a raw binary metadata to this event.
    pub fn metadata_as_binary(self, payload: Bytes) -> EventData {
        let content_bin = Some(types::Payload::Binary(payload));

        EventData {
            custom_metadata: content_bin,
            ..self
        }
    }
}

/// A structure referring to a potential logical record position in the
/// GetEventStore transaction file.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct Position {
    /// Commit position of the record.
    pub commit: u64,

    /// Prepare position of the record.
    pub prepare: u64,
}

impl Position {
    /// Points to the begin of the transaction file.
    pub fn start() -> Position {
        Position {
            commit: 0,
            prepare: 0,
        }
    }
}

impl PartialOrd for Position {
    fn partial_cmp(&self, other: &Position) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Position {
    fn cmp(&self, other: &Position) -> Ordering {
        self.commit
            .cmp(&other.commit)
            .then(self.prepare.cmp(&other.prepare))
    }
}

/// Returned after writing to a stream.
#[derive(Debug)]
pub struct WriteResult {
    /// Next expected version of the stream.
    pub next_expected_version: u64,

    /// `Position` of the write.
    pub position: Position,
}
