// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `messages.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
//const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct NewEvent {
    // message fields
    event_id: ::std::option::Option<::bytes::Bytes>,
    event_type: ::std::option::Option<::protobuf::Chars>,
    data_content_type: ::std::option::Option<i32>,
    metadata_content_type: ::std::option::Option<i32>,
    data: ::std::option::Option<::bytes::Bytes>,
    metadata: ::std::option::Option<::bytes::Bytes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NewEvent {
    fn default() -> &'a NewEvent {
        <NewEvent as ::protobuf::Message>::default_instance()
    }
}

impl NewEvent {
    pub fn new() -> NewEvent {
        ::std::default::Default::default()
    }

    // required bytes event_id = 1;


    pub fn get_event_id(&self) -> &[u8] {
        match self.event_id.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: ::bytes::Bytes) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_id(&mut self) -> &mut ::bytes::Bytes {
        if self.event_id.is_none() {
            self.event_id = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.event_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_id(&mut self) -> ::bytes::Bytes {
        self.event_id.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // required string event_type = 2;


    pub fn get_event_type(&self) -> &str {
        match self.event_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: ::protobuf::Chars) {
        self.event_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_type(&mut self) -> &mut ::protobuf::Chars {
        if self.event_type.is_none() {
            self.event_type = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.event_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_type(&mut self) -> ::protobuf::Chars {
        self.event_type.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // required int32 data_content_type = 3;


    pub fn get_data_content_type(&self) -> i32 {
        self.data_content_type.unwrap_or(0)
    }
    pub fn clear_data_content_type(&mut self) {
        self.data_content_type = ::std::option::Option::None;
    }

    pub fn has_data_content_type(&self) -> bool {
        self.data_content_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_content_type(&mut self, v: i32) {
        self.data_content_type = ::std::option::Option::Some(v);
    }

    // required int32 metadata_content_type = 4;


    pub fn get_metadata_content_type(&self) -> i32 {
        self.metadata_content_type.unwrap_or(0)
    }
    pub fn clear_metadata_content_type(&mut self) {
        self.metadata_content_type = ::std::option::Option::None;
    }

    pub fn has_metadata_content_type(&self) -> bool {
        self.metadata_content_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata_content_type(&mut self, v: i32) {
        self.metadata_content_type = ::std::option::Option::Some(v);
    }

    // required bytes data = 5;


    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::bytes::Bytes) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::bytes::Bytes {
        self.data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bytes metadata = 6;


    pub fn get_metadata(&self) -> &[u8] {
        match self.metadata.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
    pub fn clear_metadata(&mut self) {
        self.metadata = ::std::option::Option::None;
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::bytes::Bytes) {
        self.metadata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::bytes::Bytes {
        if self.metadata.is_none() {
            self.metadata = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::bytes::Bytes {
        self.metadata.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }
}

impl ::protobuf::Message for NewEvent {
    fn is_initialized(&self) -> bool {
        if self.event_id.is_none() {
            return false;
        }
        if self.event_type.is_none() {
            return false;
        }
        if self.data_content_type.is_none() {
            return false;
        }
        if self.metadata_content_type.is_none() {
            return false;
        }
        if self.data.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_carllerche_bytes_into(wire_type, is, &mut self.event_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.event_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.data_content_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.metadata_content_type = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_carllerche_bytes_into(wire_type, is, &mut self.data)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_carllerche_bytes_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.event_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.event_type.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.data_content_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.metadata_content_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.event_id.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(ref v) = self.event_type.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.data_content_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.metadata_content_type {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NewEvent {
        NewEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "event_id",
                    |m: &NewEvent| { &m.event_id },
                    |m: &mut NewEvent| { &mut m.event_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "event_type",
                    |m: &NewEvent| { &m.event_type },
                    |m: &mut NewEvent| { &mut m.event_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "data_content_type",
                    |m: &NewEvent| { &m.data_content_type },
                    |m: &mut NewEvent| { &mut m.data_content_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "metadata_content_type",
                    |m: &NewEvent| { &m.metadata_content_type },
                    |m: &mut NewEvent| { &mut m.metadata_content_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "data",
                    |m: &NewEvent| { &m.data },
                    |m: &mut NewEvent| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "metadata",
                    |m: &NewEvent| { &m.metadata },
                    |m: &mut NewEvent| { &mut m.metadata },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NewEvent>(
                    "NewEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NewEvent {
        static mut instance: ::protobuf::lazy::Lazy<NewEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NewEvent,
        };
        unsafe {
            instance.get(NewEvent::new)
        }
    }
}

impl ::protobuf::Clear for NewEvent {
    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.data_content_type = ::std::option::Option::None;
        self.metadata_content_type = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.metadata = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NewEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NewEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EventRecord {
    // message fields
    event_stream_id: ::std::option::Option<::protobuf::Chars>,
    event_number: ::std::option::Option<i64>,
    event_id: ::std::option::Option<::bytes::Bytes>,
    event_type: ::std::option::Option<::protobuf::Chars>,
    data_content_type: ::std::option::Option<i32>,
    metadata_content_type: ::std::option::Option<i32>,
    data: ::std::option::Option<::bytes::Bytes>,
    metadata: ::std::option::Option<::bytes::Bytes>,
    created: ::std::option::Option<i64>,
    created_epoch: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventRecord {
    fn default() -> &'a EventRecord {
        <EventRecord as ::protobuf::Message>::default_instance()
    }
}

impl EventRecord {
    pub fn new() -> EventRecord {
        ::std::default::Default::default()
    }

    // required string event_stream_id = 1;


    pub fn get_event_stream_id(&self) -> &str {
        match self.event_stream_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_event_stream_id(&mut self) {
        self.event_stream_id = ::std::option::Option::None;
    }

    pub fn has_event_stream_id(&self) -> bool {
        self.event_stream_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stream_id(&mut self, v: ::protobuf::Chars) {
        self.event_stream_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_stream_id(&mut self) -> &mut ::protobuf::Chars {
        if self.event_stream_id.is_none() {
            self.event_stream_id = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.event_stream_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_stream_id(&mut self) -> ::protobuf::Chars {
        self.event_stream_id.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // required int64 event_number = 2;


    pub fn get_event_number(&self) -> i64 {
        self.event_number.unwrap_or(0)
    }
    pub fn clear_event_number(&mut self) {
        self.event_number = ::std::option::Option::None;
    }

    pub fn has_event_number(&self) -> bool {
        self.event_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_number(&mut self, v: i64) {
        self.event_number = ::std::option::Option::Some(v);
    }

    // required bytes event_id = 3;


    pub fn get_event_id(&self) -> &[u8] {
        match self.event_id.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: ::bytes::Bytes) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_id(&mut self) -> &mut ::bytes::Bytes {
        if self.event_id.is_none() {
            self.event_id = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.event_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_id(&mut self) -> ::bytes::Bytes {
        self.event_id.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // required string event_type = 4;


    pub fn get_event_type(&self) -> &str {
        match self.event_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: ::protobuf::Chars) {
        self.event_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_type(&mut self) -> &mut ::protobuf::Chars {
        if self.event_type.is_none() {
            self.event_type = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.event_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_type(&mut self) -> ::protobuf::Chars {
        self.event_type.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // required int32 data_content_type = 5;


    pub fn get_data_content_type(&self) -> i32 {
        self.data_content_type.unwrap_or(0)
    }
    pub fn clear_data_content_type(&mut self) {
        self.data_content_type = ::std::option::Option::None;
    }

    pub fn has_data_content_type(&self) -> bool {
        self.data_content_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_content_type(&mut self, v: i32) {
        self.data_content_type = ::std::option::Option::Some(v);
    }

    // required int32 metadata_content_type = 6;


    pub fn get_metadata_content_type(&self) -> i32 {
        self.metadata_content_type.unwrap_or(0)
    }
    pub fn clear_metadata_content_type(&mut self) {
        self.metadata_content_type = ::std::option::Option::None;
    }

    pub fn has_metadata_content_type(&self) -> bool {
        self.metadata_content_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata_content_type(&mut self, v: i32) {
        self.metadata_content_type = ::std::option::Option::Some(v);
    }

    // required bytes data = 7;


    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::bytes::Bytes) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::bytes::Bytes {
        self.data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bytes metadata = 8;


    pub fn get_metadata(&self) -> &[u8] {
        match self.metadata.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
    pub fn clear_metadata(&mut self) {
        self.metadata = ::std::option::Option::None;
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::bytes::Bytes) {
        self.metadata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::bytes::Bytes {
        if self.metadata.is_none() {
            self.metadata = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::bytes::Bytes {
        self.metadata.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional int64 created = 9;


    pub fn get_created(&self) -> i64 {
        self.created.unwrap_or(0)
    }
    pub fn clear_created(&mut self) {
        self.created = ::std::option::Option::None;
    }

    pub fn has_created(&self) -> bool {
        self.created.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created(&mut self, v: i64) {
        self.created = ::std::option::Option::Some(v);
    }

    // optional int64 created_epoch = 10;


    pub fn get_created_epoch(&self) -> i64 {
        self.created_epoch.unwrap_or(0)
    }
    pub fn clear_created_epoch(&mut self) {
        self.created_epoch = ::std::option::Option::None;
    }

    pub fn has_created_epoch(&self) -> bool {
        self.created_epoch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_epoch(&mut self, v: i64) {
        self.created_epoch = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for EventRecord {
    fn is_initialized(&self) -> bool {
        if self.event_stream_id.is_none() {
            return false;
        }
        if self.event_number.is_none() {
            return false;
        }
        if self.event_id.is_none() {
            return false;
        }
        if self.event_type.is_none() {
            return false;
        }
        if self.data_content_type.is_none() {
            return false;
        }
        if self.metadata_content_type.is_none() {
            return false;
        }
        if self.data.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.event_stream_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.event_number = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_carllerche_bytes_into(wire_type, is, &mut self.event_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.event_type)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.data_content_type = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.metadata_content_type = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_carllerche_bytes_into(wire_type, is, &mut self.data)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_carllerche_bytes_into(wire_type, is, &mut self.metadata)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.created = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.created_epoch = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.event_stream_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.event_number {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.event_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.event_type.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.data_content_type {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.metadata_content_type {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.created {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.created_epoch {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.event_stream_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.event_number {
            os.write_int64(2, v)?;
        }
        if let Some(ref v) = self.event_id.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(ref v) = self.event_type.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.data_content_type {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.metadata_content_type {
            os.write_int32(6, v)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.created {
            os.write_int64(9, v)?;
        }
        if let Some(v) = self.created_epoch {
            os.write_int64(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventRecord {
        EventRecord::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "event_stream_id",
                    |m: &EventRecord| { &m.event_stream_id },
                    |m: &mut EventRecord| { &mut m.event_stream_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "event_number",
                    |m: &EventRecord| { &m.event_number },
                    |m: &mut EventRecord| { &mut m.event_number },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "event_id",
                    |m: &EventRecord| { &m.event_id },
                    |m: &mut EventRecord| { &mut m.event_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "event_type",
                    |m: &EventRecord| { &m.event_type },
                    |m: &mut EventRecord| { &mut m.event_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "data_content_type",
                    |m: &EventRecord| { &m.data_content_type },
                    |m: &mut EventRecord| { &mut m.data_content_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "metadata_content_type",
                    |m: &EventRecord| { &m.metadata_content_type },
                    |m: &mut EventRecord| { &mut m.metadata_content_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "data",
                    |m: &EventRecord| { &m.data },
                    |m: &mut EventRecord| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "metadata",
                    |m: &EventRecord| { &m.metadata },
                    |m: &mut EventRecord| { &mut m.metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "created",
                    |m: &EventRecord| { &m.created },
                    |m: &mut EventRecord| { &mut m.created },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "created_epoch",
                    |m: &EventRecord| { &m.created_epoch },
                    |m: &mut EventRecord| { &mut m.created_epoch },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EventRecord>(
                    "EventRecord",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EventRecord {
        static mut instance: ::protobuf::lazy::Lazy<EventRecord> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EventRecord,
        };
        unsafe {
            instance.get(EventRecord::new)
        }
    }
}

impl ::protobuf::Clear for EventRecord {
    fn clear(&mut self) {
        self.event_stream_id = ::std::option::Option::None;
        self.event_number = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.data_content_type = ::std::option::Option::None;
        self.metadata_content_type = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.metadata = ::std::option::Option::None;
        self.created = ::std::option::Option::None;
        self.created_epoch = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EventRecord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventRecord {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResolvedIndexedEvent {
    // message fields
    event: ::protobuf::SingularPtrField<EventRecord>,
    link: ::protobuf::SingularPtrField<EventRecord>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResolvedIndexedEvent {
    fn default() -> &'a ResolvedIndexedEvent {
        <ResolvedIndexedEvent as ::protobuf::Message>::default_instance()
    }
}

impl ResolvedIndexedEvent {
    pub fn new() -> ResolvedIndexedEvent {
        ::std::default::Default::default()
    }

    // optional .EventStore.Client.Messages.EventRecord event = 1;


    pub fn get_event(&self) -> &EventRecord {
        self.event.as_ref().unwrap_or_else(|| EventRecord::default_instance())
    }
    pub fn clear_event(&mut self) {
        self.event.clear();
    }

    pub fn has_event(&self) -> bool {
        self.event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event(&mut self, v: EventRecord) {
        self.event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event(&mut self) -> &mut EventRecord {
        if self.event.is_none() {
            self.event.set_default();
        }
        self.event.as_mut().unwrap()
    }

    // Take field
    pub fn take_event(&mut self) -> EventRecord {
        self.event.take().unwrap_or_else(|| EventRecord::new())
    }

    // optional .EventStore.Client.Messages.EventRecord link = 2;


    pub fn get_link(&self) -> &EventRecord {
        self.link.as_ref().unwrap_or_else(|| EventRecord::default_instance())
    }
    pub fn clear_link(&mut self) {
        self.link.clear();
    }

    pub fn has_link(&self) -> bool {
        self.link.is_some()
    }

    // Param is passed by value, moved
    pub fn set_link(&mut self, v: EventRecord) {
        self.link = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link(&mut self) -> &mut EventRecord {
        if self.link.is_none() {
            self.link.set_default();
        }
        self.link.as_mut().unwrap()
    }

    // Take field
    pub fn take_link(&mut self) -> EventRecord {
        self.link.take().unwrap_or_else(|| EventRecord::new())
    }
}

impl ::protobuf::Message for ResolvedIndexedEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.link {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.event)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.link)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.link.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.event.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.link.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResolvedIndexedEvent {
        ResolvedIndexedEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EventRecord>>(
                    "event",
                    |m: &ResolvedIndexedEvent| { &m.event },
                    |m: &mut ResolvedIndexedEvent| { &mut m.event },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EventRecord>>(
                    "link",
                    |m: &ResolvedIndexedEvent| { &m.link },
                    |m: &mut ResolvedIndexedEvent| { &mut m.link },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResolvedIndexedEvent>(
                    "ResolvedIndexedEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ResolvedIndexedEvent {
        static mut instance: ::protobuf::lazy::Lazy<ResolvedIndexedEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResolvedIndexedEvent,
        };
        unsafe {
            instance.get(ResolvedIndexedEvent::new)
        }
    }
}

impl ::protobuf::Clear for ResolvedIndexedEvent {
    fn clear(&mut self) {
        self.event.clear();
        self.link.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResolvedIndexedEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResolvedIndexedEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResolvedEvent {
    // message fields
    event: ::protobuf::SingularPtrField<EventRecord>,
    link: ::protobuf::SingularPtrField<EventRecord>,
    commit_position: ::std::option::Option<i64>,
    prepare_position: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResolvedEvent {
    fn default() -> &'a ResolvedEvent {
        <ResolvedEvent as ::protobuf::Message>::default_instance()
    }
}

impl ResolvedEvent {
    pub fn new() -> ResolvedEvent {
        ::std::default::Default::default()
    }

    // required .EventStore.Client.Messages.EventRecord event = 1;


    pub fn get_event(&self) -> &EventRecord {
        self.event.as_ref().unwrap_or_else(|| EventRecord::default_instance())
    }
    pub fn clear_event(&mut self) {
        self.event.clear();
    }

    pub fn has_event(&self) -> bool {
        self.event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event(&mut self, v: EventRecord) {
        self.event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event(&mut self) -> &mut EventRecord {
        if self.event.is_none() {
            self.event.set_default();
        }
        self.event.as_mut().unwrap()
    }

    // Take field
    pub fn take_event(&mut self) -> EventRecord {
        self.event.take().unwrap_or_else(|| EventRecord::new())
    }

    // optional .EventStore.Client.Messages.EventRecord link = 2;


    pub fn get_link(&self) -> &EventRecord {
        self.link.as_ref().unwrap_or_else(|| EventRecord::default_instance())
    }
    pub fn clear_link(&mut self) {
        self.link.clear();
    }

    pub fn has_link(&self) -> bool {
        self.link.is_some()
    }

    // Param is passed by value, moved
    pub fn set_link(&mut self, v: EventRecord) {
        self.link = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link(&mut self) -> &mut EventRecord {
        if self.link.is_none() {
            self.link.set_default();
        }
        self.link.as_mut().unwrap()
    }

    // Take field
    pub fn take_link(&mut self) -> EventRecord {
        self.link.take().unwrap_or_else(|| EventRecord::new())
    }

    // required int64 commit_position = 3;


    pub fn get_commit_position(&self) -> i64 {
        self.commit_position.unwrap_or(0)
    }
    pub fn clear_commit_position(&mut self) {
        self.commit_position = ::std::option::Option::None;
    }

    pub fn has_commit_position(&self) -> bool {
        self.commit_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commit_position(&mut self, v: i64) {
        self.commit_position = ::std::option::Option::Some(v);
    }

    // required int64 prepare_position = 4;


    pub fn get_prepare_position(&self) -> i64 {
        self.prepare_position.unwrap_or(0)
    }
    pub fn clear_prepare_position(&mut self) {
        self.prepare_position = ::std::option::Option::None;
    }

    pub fn has_prepare_position(&self) -> bool {
        self.prepare_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prepare_position(&mut self, v: i64) {
        self.prepare_position = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ResolvedEvent {
    fn is_initialized(&self) -> bool {
        if self.event.is_none() {
            return false;
        }
        if self.commit_position.is_none() {
            return false;
        }
        if self.prepare_position.is_none() {
            return false;
        }
        for v in &self.event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.link {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.event)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.link)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.commit_position = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.prepare_position = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.link.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.commit_position {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prepare_position {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.event.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.link.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.commit_position {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.prepare_position {
            os.write_int64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResolvedEvent {
        ResolvedEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EventRecord>>(
                    "event",
                    |m: &ResolvedEvent| { &m.event },
                    |m: &mut ResolvedEvent| { &mut m.event },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EventRecord>>(
                    "link",
                    |m: &ResolvedEvent| { &m.link },
                    |m: &mut ResolvedEvent| { &mut m.link },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "commit_position",
                    |m: &ResolvedEvent| { &m.commit_position },
                    |m: &mut ResolvedEvent| { &mut m.commit_position },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "prepare_position",
                    |m: &ResolvedEvent| { &m.prepare_position },
                    |m: &mut ResolvedEvent| { &mut m.prepare_position },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResolvedEvent>(
                    "ResolvedEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ResolvedEvent {
        static mut instance: ::protobuf::lazy::Lazy<ResolvedEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResolvedEvent,
        };
        unsafe {
            instance.get(ResolvedEvent::new)
        }
    }
}

impl ::protobuf::Clear for ResolvedEvent {
    fn clear(&mut self) {
        self.event.clear();
        self.link.clear();
        self.commit_position = ::std::option::Option::None;
        self.prepare_position = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResolvedEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResolvedEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteEvents {
    // message fields
    event_stream_id: ::std::option::Option<::protobuf::Chars>,
    expected_version: ::std::option::Option<i64>,
    events: ::protobuf::RepeatedField<NewEvent>,
    require_master: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WriteEvents {
    fn default() -> &'a WriteEvents {
        <WriteEvents as ::protobuf::Message>::default_instance()
    }
}

impl WriteEvents {
    pub fn new() -> WriteEvents {
        ::std::default::Default::default()
    }

    // required string event_stream_id = 1;


    pub fn get_event_stream_id(&self) -> &str {
        match self.event_stream_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_event_stream_id(&mut self) {
        self.event_stream_id = ::std::option::Option::None;
    }

    pub fn has_event_stream_id(&self) -> bool {
        self.event_stream_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stream_id(&mut self, v: ::protobuf::Chars) {
        self.event_stream_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_stream_id(&mut self) -> &mut ::protobuf::Chars {
        if self.event_stream_id.is_none() {
            self.event_stream_id = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.event_stream_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_stream_id(&mut self) -> ::protobuf::Chars {
        self.event_stream_id.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // required int64 expected_version = 2;


    pub fn get_expected_version(&self) -> i64 {
        self.expected_version.unwrap_or(0)
    }
    pub fn clear_expected_version(&mut self) {
        self.expected_version = ::std::option::Option::None;
    }

    pub fn has_expected_version(&self) -> bool {
        self.expected_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expected_version(&mut self, v: i64) {
        self.expected_version = ::std::option::Option::Some(v);
    }

    // repeated .EventStore.Client.Messages.NewEvent events = 3;


    pub fn get_events(&self) -> &[NewEvent] {
        &self.events
    }
    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::protobuf::RepeatedField<NewEvent>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events(&mut self) -> &mut ::protobuf::RepeatedField<NewEvent> {
        &mut self.events
    }

    // Take field
    pub fn take_events(&mut self) -> ::protobuf::RepeatedField<NewEvent> {
        ::std::mem::replace(&mut self.events, ::protobuf::RepeatedField::new())
    }

    // required bool require_master = 4;


    pub fn get_require_master(&self) -> bool {
        self.require_master.unwrap_or(false)
    }
    pub fn clear_require_master(&mut self) {
        self.require_master = ::std::option::Option::None;
    }

    pub fn has_require_master(&self) -> bool {
        self.require_master.is_some()
    }

    // Param is passed by value, moved
    pub fn set_require_master(&mut self, v: bool) {
        self.require_master = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for WriteEvents {
    fn is_initialized(&self) -> bool {
        if self.event_stream_id.is_none() {
            return false;
        }
        if self.expected_version.is_none() {
            return false;
        }
        if self.require_master.is_none() {
            return false;
        }
        for v in &self.events {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.event_stream_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expected_version = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.events)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.require_master = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.event_stream_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.expected_version {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.require_master {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.event_stream_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.expected_version {
            os.write_int64(2, v)?;
        }
        for v in &self.events {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.require_master {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteEvents {
        WriteEvents::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "event_stream_id",
                    |m: &WriteEvents| { &m.event_stream_id },
                    |m: &mut WriteEvents| { &mut m.event_stream_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "expected_version",
                    |m: &WriteEvents| { &m.expected_version },
                    |m: &mut WriteEvents| { &mut m.expected_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NewEvent>>(
                    "events",
                    |m: &WriteEvents| { &m.events },
                    |m: &mut WriteEvents| { &mut m.events },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "require_master",
                    |m: &WriteEvents| { &m.require_master },
                    |m: &mut WriteEvents| { &mut m.require_master },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WriteEvents>(
                    "WriteEvents",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WriteEvents {
        static mut instance: ::protobuf::lazy::Lazy<WriteEvents> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WriteEvents,
        };
        unsafe {
            instance.get(WriteEvents::new)
        }
    }
}

impl ::protobuf::Clear for WriteEvents {
    fn clear(&mut self) {
        self.event_stream_id = ::std::option::Option::None;
        self.expected_version = ::std::option::Option::None;
        self.events.clear();
        self.require_master = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WriteEvents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteEvents {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteEventsCompleted {
    // message fields
    result: ::std::option::Option<OperationResult>,
    message: ::std::option::Option<::protobuf::Chars>,
    first_event_number: ::std::option::Option<i64>,
    last_event_number: ::std::option::Option<i64>,
    prepare_position: ::std::option::Option<i64>,
    commit_position: ::std::option::Option<i64>,
    current_version: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WriteEventsCompleted {
    fn default() -> &'a WriteEventsCompleted {
        <WriteEventsCompleted as ::protobuf::Message>::default_instance()
    }
}

impl WriteEventsCompleted {
    pub fn new() -> WriteEventsCompleted {
        ::std::default::Default::default()
    }

    // required .EventStore.Client.Messages.OperationResult result = 1;


    pub fn get_result(&self) -> OperationResult {
        self.result.unwrap_or(OperationResult::Success)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OperationResult) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional string message = 2;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        self.message.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // required int64 first_event_number = 3;


    pub fn get_first_event_number(&self) -> i64 {
        self.first_event_number.unwrap_or(0)
    }
    pub fn clear_first_event_number(&mut self) {
        self.first_event_number = ::std::option::Option::None;
    }

    pub fn has_first_event_number(&self) -> bool {
        self.first_event_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_event_number(&mut self, v: i64) {
        self.first_event_number = ::std::option::Option::Some(v);
    }

    // required int64 last_event_number = 4;


    pub fn get_last_event_number(&self) -> i64 {
        self.last_event_number.unwrap_or(0)
    }
    pub fn clear_last_event_number(&mut self) {
        self.last_event_number = ::std::option::Option::None;
    }

    pub fn has_last_event_number(&self) -> bool {
        self.last_event_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_event_number(&mut self, v: i64) {
        self.last_event_number = ::std::option::Option::Some(v);
    }

    // optional int64 prepare_position = 5;


    pub fn get_prepare_position(&self) -> i64 {
        self.prepare_position.unwrap_or(0)
    }
    pub fn clear_prepare_position(&mut self) {
        self.prepare_position = ::std::option::Option::None;
    }

    pub fn has_prepare_position(&self) -> bool {
        self.prepare_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prepare_position(&mut self, v: i64) {
        self.prepare_position = ::std::option::Option::Some(v);
    }

    // optional int64 commit_position = 6;


    pub fn get_commit_position(&self) -> i64 {
        self.commit_position.unwrap_or(0)
    }
    pub fn clear_commit_position(&mut self) {
        self.commit_position = ::std::option::Option::None;
    }

    pub fn has_commit_position(&self) -> bool {
        self.commit_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commit_position(&mut self, v: i64) {
        self.commit_position = ::std::option::Option::Some(v);
    }

    // optional int64 current_version = 7;


    pub fn get_current_version(&self) -> i64 {
        self.current_version.unwrap_or(0)
    }
    pub fn clear_current_version(&mut self) {
        self.current_version = ::std::option::Option::None;
    }

    pub fn has_current_version(&self) -> bool {
        self.current_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_version(&mut self, v: i64) {
        self.current_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for WriteEventsCompleted {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        if self.first_event_number.is_none() {
            return false;
        }
        if self.last_event_number.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.first_event_number = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.last_event_number = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.prepare_position = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.commit_position = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.current_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.first_event_number {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_event_number {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prepare_position {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.commit_position {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.current_version {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.first_event_number {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.last_event_number {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.prepare_position {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.commit_position {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.current_version {
            os.write_int64(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteEventsCompleted {
        WriteEventsCompleted::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OperationResult>>(
                    "result",
                    |m: &WriteEventsCompleted| { &m.result },
                    |m: &mut WriteEventsCompleted| { &mut m.result },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &WriteEventsCompleted| { &m.message },
                    |m: &mut WriteEventsCompleted| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "first_event_number",
                    |m: &WriteEventsCompleted| { &m.first_event_number },
                    |m: &mut WriteEventsCompleted| { &mut m.first_event_number },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "last_event_number",
                    |m: &WriteEventsCompleted| { &m.last_event_number },
                    |m: &mut WriteEventsCompleted| { &mut m.last_event_number },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "prepare_position",
                    |m: &WriteEventsCompleted| { &m.prepare_position },
                    |m: &mut WriteEventsCompleted| { &mut m.prepare_position },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "commit_position",
                    |m: &WriteEventsCompleted| { &m.commit_position },
                    |m: &mut WriteEventsCompleted| { &mut m.commit_position },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "current_version",
                    |m: &WriteEventsCompleted| { &m.current_version },
                    |m: &mut WriteEventsCompleted| { &mut m.current_version },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WriteEventsCompleted>(
                    "WriteEventsCompleted",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WriteEventsCompleted {
        static mut instance: ::protobuf::lazy::Lazy<WriteEventsCompleted> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WriteEventsCompleted,
        };
        unsafe {
            instance.get(WriteEventsCompleted::new)
        }
    }
}

impl ::protobuf::Clear for WriteEventsCompleted {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.first_event_number = ::std::option::Option::None;
        self.last_event_number = ::std::option::Option::None;
        self.prepare_position = ::std::option::Option::None;
        self.commit_position = ::std::option::Option::None;
        self.current_version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WriteEventsCompleted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteEventsCompleted {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteStream {
    // message fields
    event_stream_id: ::std::option::Option<::protobuf::Chars>,
    expected_version: ::std::option::Option<i64>,
    require_master: ::std::option::Option<bool>,
    hard_delete: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteStream {
    fn default() -> &'a DeleteStream {
        <DeleteStream as ::protobuf::Message>::default_instance()
    }
}

impl DeleteStream {
    pub fn new() -> DeleteStream {
        ::std::default::Default::default()
    }

    // required string event_stream_id = 1;


    pub fn get_event_stream_id(&self) -> &str {
        match self.event_stream_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_event_stream_id(&mut self) {
        self.event_stream_id = ::std::option::Option::None;
    }

    pub fn has_event_stream_id(&self) -> bool {
        self.event_stream_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stream_id(&mut self, v: ::protobuf::Chars) {
        self.event_stream_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_stream_id(&mut self) -> &mut ::protobuf::Chars {
        if self.event_stream_id.is_none() {
            self.event_stream_id = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.event_stream_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_stream_id(&mut self) -> ::protobuf::Chars {
        self.event_stream_id.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // required int64 expected_version = 2;


    pub fn get_expected_version(&self) -> i64 {
        self.expected_version.unwrap_or(0)
    }
    pub fn clear_expected_version(&mut self) {
        self.expected_version = ::std::option::Option::None;
    }

    pub fn has_expected_version(&self) -> bool {
        self.expected_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expected_version(&mut self, v: i64) {
        self.expected_version = ::std::option::Option::Some(v);
    }

    // required bool require_master = 3;


    pub fn get_require_master(&self) -> bool {
        self.require_master.unwrap_or(false)
    }
    pub fn clear_require_master(&mut self) {
        self.require_master = ::std::option::Option::None;
    }

    pub fn has_require_master(&self) -> bool {
        self.require_master.is_some()
    }

    // Param is passed by value, moved
    pub fn set_require_master(&mut self, v: bool) {
        self.require_master = ::std::option::Option::Some(v);
    }

    // optional bool hard_delete = 4;


    pub fn get_hard_delete(&self) -> bool {
        self.hard_delete.unwrap_or(false)
    }
    pub fn clear_hard_delete(&mut self) {
        self.hard_delete = ::std::option::Option::None;
    }

    pub fn has_hard_delete(&self) -> bool {
        self.hard_delete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hard_delete(&mut self, v: bool) {
        self.hard_delete = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DeleteStream {
    fn is_initialized(&self) -> bool {
        if self.event_stream_id.is_none() {
            return false;
        }
        if self.expected_version.is_none() {
            return false;
        }
        if self.require_master.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.event_stream_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expected_version = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.require_master = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hard_delete = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.event_stream_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.expected_version {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.require_master {
            my_size += 2;
        }
        if let Some(v) = self.hard_delete {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.event_stream_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.expected_version {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.require_master {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.hard_delete {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteStream {
        DeleteStream::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "event_stream_id",
                    |m: &DeleteStream| { &m.event_stream_id },
                    |m: &mut DeleteStream| { &mut m.event_stream_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "expected_version",
                    |m: &DeleteStream| { &m.expected_version },
                    |m: &mut DeleteStream| { &mut m.expected_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "require_master",
                    |m: &DeleteStream| { &m.require_master },
                    |m: &mut DeleteStream| { &mut m.require_master },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "hard_delete",
                    |m: &DeleteStream| { &m.hard_delete },
                    |m: &mut DeleteStream| { &mut m.hard_delete },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteStream>(
                    "DeleteStream",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteStream {
        static mut instance: ::protobuf::lazy::Lazy<DeleteStream> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteStream,
        };
        unsafe {
            instance.get(DeleteStream::new)
        }
    }
}

impl ::protobuf::Clear for DeleteStream {
    fn clear(&mut self) {
        self.event_stream_id = ::std::option::Option::None;
        self.expected_version = ::std::option::Option::None;
        self.require_master = ::std::option::Option::None;
        self.hard_delete = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteStream {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteStream {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteStreamCompleted {
    // message fields
    result: ::std::option::Option<OperationResult>,
    message: ::std::option::Option<::protobuf::Chars>,
    prepare_position: ::std::option::Option<i64>,
    commit_position: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteStreamCompleted {
    fn default() -> &'a DeleteStreamCompleted {
        <DeleteStreamCompleted as ::protobuf::Message>::default_instance()
    }
}

impl DeleteStreamCompleted {
    pub fn new() -> DeleteStreamCompleted {
        ::std::default::Default::default()
    }

    // required .EventStore.Client.Messages.OperationResult result = 1;


    pub fn get_result(&self) -> OperationResult {
        self.result.unwrap_or(OperationResult::Success)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OperationResult) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional string message = 2;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        self.message.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional int64 prepare_position = 3;


    pub fn get_prepare_position(&self) -> i64 {
        self.prepare_position.unwrap_or(0)
    }
    pub fn clear_prepare_position(&mut self) {
        self.prepare_position = ::std::option::Option::None;
    }

    pub fn has_prepare_position(&self) -> bool {
        self.prepare_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prepare_position(&mut self, v: i64) {
        self.prepare_position = ::std::option::Option::Some(v);
    }

    // optional int64 commit_position = 4;


    pub fn get_commit_position(&self) -> i64 {
        self.commit_position.unwrap_or(0)
    }
    pub fn clear_commit_position(&mut self) {
        self.commit_position = ::std::option::Option::None;
    }

    pub fn has_commit_position(&self) -> bool {
        self.commit_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commit_position(&mut self, v: i64) {
        self.commit_position = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DeleteStreamCompleted {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.prepare_position = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.commit_position = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.prepare_position {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.commit_position {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.prepare_position {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.commit_position {
            os.write_int64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteStreamCompleted {
        DeleteStreamCompleted::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OperationResult>>(
                    "result",
                    |m: &DeleteStreamCompleted| { &m.result },
                    |m: &mut DeleteStreamCompleted| { &mut m.result },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &DeleteStreamCompleted| { &m.message },
                    |m: &mut DeleteStreamCompleted| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "prepare_position",
                    |m: &DeleteStreamCompleted| { &m.prepare_position },
                    |m: &mut DeleteStreamCompleted| { &mut m.prepare_position },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "commit_position",
                    |m: &DeleteStreamCompleted| { &m.commit_position },
                    |m: &mut DeleteStreamCompleted| { &mut m.commit_position },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteStreamCompleted>(
                    "DeleteStreamCompleted",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteStreamCompleted {
        static mut instance: ::protobuf::lazy::Lazy<DeleteStreamCompleted> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteStreamCompleted,
        };
        unsafe {
            instance.get(DeleteStreamCompleted::new)
        }
    }
}

impl ::protobuf::Clear for DeleteStreamCompleted {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.prepare_position = ::std::option::Option::None;
        self.commit_position = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteStreamCompleted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteStreamCompleted {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionStart {
    // message fields
    event_stream_id: ::std::option::Option<::protobuf::Chars>,
    expected_version: ::std::option::Option<i64>,
    require_master: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionStart {
    fn default() -> &'a TransactionStart {
        <TransactionStart as ::protobuf::Message>::default_instance()
    }
}

impl TransactionStart {
    pub fn new() -> TransactionStart {
        ::std::default::Default::default()
    }

    // required string event_stream_id = 1;


    pub fn get_event_stream_id(&self) -> &str {
        match self.event_stream_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_event_stream_id(&mut self) {
        self.event_stream_id = ::std::option::Option::None;
    }

    pub fn has_event_stream_id(&self) -> bool {
        self.event_stream_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stream_id(&mut self, v: ::protobuf::Chars) {
        self.event_stream_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_stream_id(&mut self) -> &mut ::protobuf::Chars {
        if self.event_stream_id.is_none() {
            self.event_stream_id = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.event_stream_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_stream_id(&mut self) -> ::protobuf::Chars {
        self.event_stream_id.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // required int64 expected_version = 2;


    pub fn get_expected_version(&self) -> i64 {
        self.expected_version.unwrap_or(0)
    }
    pub fn clear_expected_version(&mut self) {
        self.expected_version = ::std::option::Option::None;
    }

    pub fn has_expected_version(&self) -> bool {
        self.expected_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expected_version(&mut self, v: i64) {
        self.expected_version = ::std::option::Option::Some(v);
    }

    // required bool require_master = 3;


    pub fn get_require_master(&self) -> bool {
        self.require_master.unwrap_or(false)
    }
    pub fn clear_require_master(&mut self) {
        self.require_master = ::std::option::Option::None;
    }

    pub fn has_require_master(&self) -> bool {
        self.require_master.is_some()
    }

    // Param is passed by value, moved
    pub fn set_require_master(&mut self, v: bool) {
        self.require_master = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TransactionStart {
    fn is_initialized(&self) -> bool {
        if self.event_stream_id.is_none() {
            return false;
        }
        if self.expected_version.is_none() {
            return false;
        }
        if self.require_master.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.event_stream_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expected_version = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.require_master = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.event_stream_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.expected_version {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.require_master {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.event_stream_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.expected_version {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.require_master {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionStart {
        TransactionStart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "event_stream_id",
                    |m: &TransactionStart| { &m.event_stream_id },
                    |m: &mut TransactionStart| { &mut m.event_stream_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "expected_version",
                    |m: &TransactionStart| { &m.expected_version },
                    |m: &mut TransactionStart| { &mut m.expected_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "require_master",
                    |m: &TransactionStart| { &m.require_master },
                    |m: &mut TransactionStart| { &mut m.require_master },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionStart>(
                    "TransactionStart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionStart {
        static mut instance: ::protobuf::lazy::Lazy<TransactionStart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionStart,
        };
        unsafe {
            instance.get(TransactionStart::new)
        }
    }
}

impl ::protobuf::Clear for TransactionStart {
    fn clear(&mut self) {
        self.event_stream_id = ::std::option::Option::None;
        self.expected_version = ::std::option::Option::None;
        self.require_master = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionStart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionStart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionStartCompleted {
    // message fields
    transaction_id: ::std::option::Option<i64>,
    result: ::std::option::Option<OperationResult>,
    message: ::std::option::Option<::protobuf::Chars>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionStartCompleted {
    fn default() -> &'a TransactionStartCompleted {
        <TransactionStartCompleted as ::protobuf::Message>::default_instance()
    }
}

impl TransactionStartCompleted {
    pub fn new() -> TransactionStartCompleted {
        ::std::default::Default::default()
    }

    // required int64 transaction_id = 1;


    pub fn get_transaction_id(&self) -> i64 {
        self.transaction_id.unwrap_or(0)
    }
    pub fn clear_transaction_id(&mut self) {
        self.transaction_id = ::std::option::Option::None;
    }

    pub fn has_transaction_id(&self) -> bool {
        self.transaction_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction_id(&mut self, v: i64) {
        self.transaction_id = ::std::option::Option::Some(v);
    }

    // required .EventStore.Client.Messages.OperationResult result = 2;


    pub fn get_result(&self) -> OperationResult {
        self.result.unwrap_or(OperationResult::Success)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OperationResult) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional string message = 3;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        self.message.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for TransactionStartCompleted {
    fn is_initialized(&self) -> bool {
        if self.transaction_id.is_none() {
            return false;
        }
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.transaction_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.transaction_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.transaction_id {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.result {
            os.write_enum(2, v.value())?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionStartCompleted {
        TransactionStartCompleted::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "transaction_id",
                    |m: &TransactionStartCompleted| { &m.transaction_id },
                    |m: &mut TransactionStartCompleted| { &mut m.transaction_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OperationResult>>(
                    "result",
                    |m: &TransactionStartCompleted| { &m.result },
                    |m: &mut TransactionStartCompleted| { &mut m.result },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &TransactionStartCompleted| { &m.message },
                    |m: &mut TransactionStartCompleted| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionStartCompleted>(
                    "TransactionStartCompleted",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionStartCompleted {
        static mut instance: ::protobuf::lazy::Lazy<TransactionStartCompleted> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionStartCompleted,
        };
        unsafe {
            instance.get(TransactionStartCompleted::new)
        }
    }
}

impl ::protobuf::Clear for TransactionStartCompleted {
    fn clear(&mut self) {
        self.transaction_id = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionStartCompleted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionStartCompleted {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionWrite {
    // message fields
    transaction_id: ::std::option::Option<i64>,
    events: ::protobuf::RepeatedField<NewEvent>,
    require_master: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionWrite {
    fn default() -> &'a TransactionWrite {
        <TransactionWrite as ::protobuf::Message>::default_instance()
    }
}

impl TransactionWrite {
    pub fn new() -> TransactionWrite {
        ::std::default::Default::default()
    }

    // required int64 transaction_id = 1;


    pub fn get_transaction_id(&self) -> i64 {
        self.transaction_id.unwrap_or(0)
    }
    pub fn clear_transaction_id(&mut self) {
        self.transaction_id = ::std::option::Option::None;
    }

    pub fn has_transaction_id(&self) -> bool {
        self.transaction_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction_id(&mut self, v: i64) {
        self.transaction_id = ::std::option::Option::Some(v);
    }

    // repeated .EventStore.Client.Messages.NewEvent events = 2;


    pub fn get_events(&self) -> &[NewEvent] {
        &self.events
    }
    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::protobuf::RepeatedField<NewEvent>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events(&mut self) -> &mut ::protobuf::RepeatedField<NewEvent> {
        &mut self.events
    }

    // Take field
    pub fn take_events(&mut self) -> ::protobuf::RepeatedField<NewEvent> {
        ::std::mem::replace(&mut self.events, ::protobuf::RepeatedField::new())
    }

    // required bool require_master = 3;


    pub fn get_require_master(&self) -> bool {
        self.require_master.unwrap_or(false)
    }
    pub fn clear_require_master(&mut self) {
        self.require_master = ::std::option::Option::None;
    }

    pub fn has_require_master(&self) -> bool {
        self.require_master.is_some()
    }

    // Param is passed by value, moved
    pub fn set_require_master(&mut self, v: bool) {
        self.require_master = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TransactionWrite {
    fn is_initialized(&self) -> bool {
        if self.transaction_id.is_none() {
            return false;
        }
        if self.require_master.is_none() {
            return false;
        }
        for v in &self.events {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.transaction_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.events)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.require_master = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.transaction_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.require_master {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.transaction_id {
            os.write_int64(1, v)?;
        }
        for v in &self.events {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.require_master {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionWrite {
        TransactionWrite::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "transaction_id",
                    |m: &TransactionWrite| { &m.transaction_id },
                    |m: &mut TransactionWrite| { &mut m.transaction_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NewEvent>>(
                    "events",
                    |m: &TransactionWrite| { &m.events },
                    |m: &mut TransactionWrite| { &mut m.events },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "require_master",
                    |m: &TransactionWrite| { &m.require_master },
                    |m: &mut TransactionWrite| { &mut m.require_master },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionWrite>(
                    "TransactionWrite",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionWrite {
        static mut instance: ::protobuf::lazy::Lazy<TransactionWrite> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionWrite,
        };
        unsafe {
            instance.get(TransactionWrite::new)
        }
    }
}

impl ::protobuf::Clear for TransactionWrite {
    fn clear(&mut self) {
        self.transaction_id = ::std::option::Option::None;
        self.events.clear();
        self.require_master = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionWrite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionWrite {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionWriteCompleted {
    // message fields
    transaction_id: ::std::option::Option<i64>,
    result: ::std::option::Option<OperationResult>,
    message: ::std::option::Option<::protobuf::Chars>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionWriteCompleted {
    fn default() -> &'a TransactionWriteCompleted {
        <TransactionWriteCompleted as ::protobuf::Message>::default_instance()
    }
}

impl TransactionWriteCompleted {
    pub fn new() -> TransactionWriteCompleted {
        ::std::default::Default::default()
    }

    // required int64 transaction_id = 1;


    pub fn get_transaction_id(&self) -> i64 {
        self.transaction_id.unwrap_or(0)
    }
    pub fn clear_transaction_id(&mut self) {
        self.transaction_id = ::std::option::Option::None;
    }

    pub fn has_transaction_id(&self) -> bool {
        self.transaction_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction_id(&mut self, v: i64) {
        self.transaction_id = ::std::option::Option::Some(v);
    }

    // required .EventStore.Client.Messages.OperationResult result = 2;


    pub fn get_result(&self) -> OperationResult {
        self.result.unwrap_or(OperationResult::Success)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OperationResult) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional string message = 3;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        self.message.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for TransactionWriteCompleted {
    fn is_initialized(&self) -> bool {
        if self.transaction_id.is_none() {
            return false;
        }
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.transaction_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.transaction_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.transaction_id {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.result {
            os.write_enum(2, v.value())?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionWriteCompleted {
        TransactionWriteCompleted::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "transaction_id",
                    |m: &TransactionWriteCompleted| { &m.transaction_id },
                    |m: &mut TransactionWriteCompleted| { &mut m.transaction_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OperationResult>>(
                    "result",
                    |m: &TransactionWriteCompleted| { &m.result },
                    |m: &mut TransactionWriteCompleted| { &mut m.result },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &TransactionWriteCompleted| { &m.message },
                    |m: &mut TransactionWriteCompleted| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionWriteCompleted>(
                    "TransactionWriteCompleted",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionWriteCompleted {
        static mut instance: ::protobuf::lazy::Lazy<TransactionWriteCompleted> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionWriteCompleted,
        };
        unsafe {
            instance.get(TransactionWriteCompleted::new)
        }
    }
}

impl ::protobuf::Clear for TransactionWriteCompleted {
    fn clear(&mut self) {
        self.transaction_id = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionWriteCompleted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionWriteCompleted {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionCommit {
    // message fields
    transaction_id: ::std::option::Option<i64>,
    require_master: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionCommit {
    fn default() -> &'a TransactionCommit {
        <TransactionCommit as ::protobuf::Message>::default_instance()
    }
}

impl TransactionCommit {
    pub fn new() -> TransactionCommit {
        ::std::default::Default::default()
    }

    // required int64 transaction_id = 1;


    pub fn get_transaction_id(&self) -> i64 {
        self.transaction_id.unwrap_or(0)
    }
    pub fn clear_transaction_id(&mut self) {
        self.transaction_id = ::std::option::Option::None;
    }

    pub fn has_transaction_id(&self) -> bool {
        self.transaction_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction_id(&mut self, v: i64) {
        self.transaction_id = ::std::option::Option::Some(v);
    }

    // required bool require_master = 2;


    pub fn get_require_master(&self) -> bool {
        self.require_master.unwrap_or(false)
    }
    pub fn clear_require_master(&mut self) {
        self.require_master = ::std::option::Option::None;
    }

    pub fn has_require_master(&self) -> bool {
        self.require_master.is_some()
    }

    // Param is passed by value, moved
    pub fn set_require_master(&mut self, v: bool) {
        self.require_master = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TransactionCommit {
    fn is_initialized(&self) -> bool {
        if self.transaction_id.is_none() {
            return false;
        }
        if self.require_master.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.transaction_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.require_master = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.transaction_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.require_master {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.transaction_id {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.require_master {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionCommit {
        TransactionCommit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "transaction_id",
                    |m: &TransactionCommit| { &m.transaction_id },
                    |m: &mut TransactionCommit| { &mut m.transaction_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "require_master",
                    |m: &TransactionCommit| { &m.require_master },
                    |m: &mut TransactionCommit| { &mut m.require_master },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionCommit>(
                    "TransactionCommit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionCommit {
        static mut instance: ::protobuf::lazy::Lazy<TransactionCommit> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionCommit,
        };
        unsafe {
            instance.get(TransactionCommit::new)
        }
    }
}

impl ::protobuf::Clear for TransactionCommit {
    fn clear(&mut self) {
        self.transaction_id = ::std::option::Option::None;
        self.require_master = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionCommit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionCommit {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionCommitCompleted {
    // message fields
    transaction_id: ::std::option::Option<i64>,
    result: ::std::option::Option<OperationResult>,
    message: ::std::option::Option<::protobuf::Chars>,
    first_event_number: ::std::option::Option<i64>,
    last_event_number: ::std::option::Option<i64>,
    prepare_position: ::std::option::Option<i64>,
    commit_position: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionCommitCompleted {
    fn default() -> &'a TransactionCommitCompleted {
        <TransactionCommitCompleted as ::protobuf::Message>::default_instance()
    }
}

impl TransactionCommitCompleted {
    pub fn new() -> TransactionCommitCompleted {
        ::std::default::Default::default()
    }

    // required int64 transaction_id = 1;


    pub fn get_transaction_id(&self) -> i64 {
        self.transaction_id.unwrap_or(0)
    }
    pub fn clear_transaction_id(&mut self) {
        self.transaction_id = ::std::option::Option::None;
    }

    pub fn has_transaction_id(&self) -> bool {
        self.transaction_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction_id(&mut self, v: i64) {
        self.transaction_id = ::std::option::Option::Some(v);
    }

    // required .EventStore.Client.Messages.OperationResult result = 2;


    pub fn get_result(&self) -> OperationResult {
        self.result.unwrap_or(OperationResult::Success)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OperationResult) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional string message = 3;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        self.message.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // required int64 first_event_number = 4;


    pub fn get_first_event_number(&self) -> i64 {
        self.first_event_number.unwrap_or(0)
    }
    pub fn clear_first_event_number(&mut self) {
        self.first_event_number = ::std::option::Option::None;
    }

    pub fn has_first_event_number(&self) -> bool {
        self.first_event_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_event_number(&mut self, v: i64) {
        self.first_event_number = ::std::option::Option::Some(v);
    }

    // required int64 last_event_number = 5;


    pub fn get_last_event_number(&self) -> i64 {
        self.last_event_number.unwrap_or(0)
    }
    pub fn clear_last_event_number(&mut self) {
        self.last_event_number = ::std::option::Option::None;
    }

    pub fn has_last_event_number(&self) -> bool {
        self.last_event_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_event_number(&mut self, v: i64) {
        self.last_event_number = ::std::option::Option::Some(v);
    }

    // optional int64 prepare_position = 6;


    pub fn get_prepare_position(&self) -> i64 {
        self.prepare_position.unwrap_or(0)
    }
    pub fn clear_prepare_position(&mut self) {
        self.prepare_position = ::std::option::Option::None;
    }

    pub fn has_prepare_position(&self) -> bool {
        self.prepare_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prepare_position(&mut self, v: i64) {
        self.prepare_position = ::std::option::Option::Some(v);
    }

    // optional int64 commit_position = 7;


    pub fn get_commit_position(&self) -> i64 {
        self.commit_position.unwrap_or(0)
    }
    pub fn clear_commit_position(&mut self) {
        self.commit_position = ::std::option::Option::None;
    }

    pub fn has_commit_position(&self) -> bool {
        self.commit_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commit_position(&mut self, v: i64) {
        self.commit_position = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TransactionCommitCompleted {
    fn is_initialized(&self) -> bool {
        if self.transaction_id.is_none() {
            return false;
        }
        if self.result.is_none() {
            return false;
        }
        if self.first_event_number.is_none() {
            return false;
        }
        if self.last_event_number.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.transaction_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.first_event_number = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.last_event_number = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.prepare_position = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.commit_position = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.transaction_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.first_event_number {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_event_number {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prepare_position {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.commit_position {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.transaction_id {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.result {
            os.write_enum(2, v.value())?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.first_event_number {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.last_event_number {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.prepare_position {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.commit_position {
            os.write_int64(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionCommitCompleted {
        TransactionCommitCompleted::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "transaction_id",
                    |m: &TransactionCommitCompleted| { &m.transaction_id },
                    |m: &mut TransactionCommitCompleted| { &mut m.transaction_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OperationResult>>(
                    "result",
                    |m: &TransactionCommitCompleted| { &m.result },
                    |m: &mut TransactionCommitCompleted| { &mut m.result },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &TransactionCommitCompleted| { &m.message },
                    |m: &mut TransactionCommitCompleted| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "first_event_number",
                    |m: &TransactionCommitCompleted| { &m.first_event_number },
                    |m: &mut TransactionCommitCompleted| { &mut m.first_event_number },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "last_event_number",
                    |m: &TransactionCommitCompleted| { &m.last_event_number },
                    |m: &mut TransactionCommitCompleted| { &mut m.last_event_number },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "prepare_position",
                    |m: &TransactionCommitCompleted| { &m.prepare_position },
                    |m: &mut TransactionCommitCompleted| { &mut m.prepare_position },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "commit_position",
                    |m: &TransactionCommitCompleted| { &m.commit_position },
                    |m: &mut TransactionCommitCompleted| { &mut m.commit_position },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionCommitCompleted>(
                    "TransactionCommitCompleted",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionCommitCompleted {
        static mut instance: ::protobuf::lazy::Lazy<TransactionCommitCompleted> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionCommitCompleted,
        };
        unsafe {
            instance.get(TransactionCommitCompleted::new)
        }
    }
}

impl ::protobuf::Clear for TransactionCommitCompleted {
    fn clear(&mut self) {
        self.transaction_id = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.first_event_number = ::std::option::Option::None;
        self.last_event_number = ::std::option::Option::None;
        self.prepare_position = ::std::option::Option::None;
        self.commit_position = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionCommitCompleted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionCommitCompleted {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadEvent {
    // message fields
    event_stream_id: ::std::option::Option<::protobuf::Chars>,
    event_number: ::std::option::Option<i64>,
    resolve_link_tos: ::std::option::Option<bool>,
    require_master: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadEvent {
    fn default() -> &'a ReadEvent {
        <ReadEvent as ::protobuf::Message>::default_instance()
    }
}

impl ReadEvent {
    pub fn new() -> ReadEvent {
        ::std::default::Default::default()
    }

    // required string event_stream_id = 1;


    pub fn get_event_stream_id(&self) -> &str {
        match self.event_stream_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_event_stream_id(&mut self) {
        self.event_stream_id = ::std::option::Option::None;
    }

    pub fn has_event_stream_id(&self) -> bool {
        self.event_stream_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stream_id(&mut self, v: ::protobuf::Chars) {
        self.event_stream_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_stream_id(&mut self) -> &mut ::protobuf::Chars {
        if self.event_stream_id.is_none() {
            self.event_stream_id = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.event_stream_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_stream_id(&mut self) -> ::protobuf::Chars {
        self.event_stream_id.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // required int64 event_number = 2;


    pub fn get_event_number(&self) -> i64 {
        self.event_number.unwrap_or(0)
    }
    pub fn clear_event_number(&mut self) {
        self.event_number = ::std::option::Option::None;
    }

    pub fn has_event_number(&self) -> bool {
        self.event_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_number(&mut self, v: i64) {
        self.event_number = ::std::option::Option::Some(v);
    }

    // required bool resolve_link_tos = 3;


    pub fn get_resolve_link_tos(&self) -> bool {
        self.resolve_link_tos.unwrap_or(false)
    }
    pub fn clear_resolve_link_tos(&mut self) {
        self.resolve_link_tos = ::std::option::Option::None;
    }

    pub fn has_resolve_link_tos(&self) -> bool {
        self.resolve_link_tos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resolve_link_tos(&mut self, v: bool) {
        self.resolve_link_tos = ::std::option::Option::Some(v);
    }

    // required bool require_master = 4;


    pub fn get_require_master(&self) -> bool {
        self.require_master.unwrap_or(false)
    }
    pub fn clear_require_master(&mut self) {
        self.require_master = ::std::option::Option::None;
    }

    pub fn has_require_master(&self) -> bool {
        self.require_master.is_some()
    }

    // Param is passed by value, moved
    pub fn set_require_master(&mut self, v: bool) {
        self.require_master = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ReadEvent {
    fn is_initialized(&self) -> bool {
        if self.event_stream_id.is_none() {
            return false;
        }
        if self.event_number.is_none() {
            return false;
        }
        if self.resolve_link_tos.is_none() {
            return false;
        }
        if self.require_master.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.event_stream_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.event_number = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.resolve_link_tos = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.require_master = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.event_stream_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.event_number {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.resolve_link_tos {
            my_size += 2;
        }
        if let Some(v) = self.require_master {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.event_stream_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.event_number {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.resolve_link_tos {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.require_master {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadEvent {
        ReadEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "event_stream_id",
                    |m: &ReadEvent| { &m.event_stream_id },
                    |m: &mut ReadEvent| { &mut m.event_stream_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "event_number",
                    |m: &ReadEvent| { &m.event_number },
                    |m: &mut ReadEvent| { &mut m.event_number },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "resolve_link_tos",
                    |m: &ReadEvent| { &m.resolve_link_tos },
                    |m: &mut ReadEvent| { &mut m.resolve_link_tos },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "require_master",
                    |m: &ReadEvent| { &m.require_master },
                    |m: &mut ReadEvent| { &mut m.require_master },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReadEvent>(
                    "ReadEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReadEvent {
        static mut instance: ::protobuf::lazy::Lazy<ReadEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReadEvent,
        };
        unsafe {
            instance.get(ReadEvent::new)
        }
    }
}

impl ::protobuf::Clear for ReadEvent {
    fn clear(&mut self) {
        self.event_stream_id = ::std::option::Option::None;
        self.event_number = ::std::option::Option::None;
        self.resolve_link_tos = ::std::option::Option::None;
        self.require_master = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadEventCompleted {
    // message fields
    result: ::std::option::Option<ReadEventCompleted_ReadEventResult>,
    event: ::protobuf::SingularPtrField<ResolvedIndexedEvent>,
    error: ::std::option::Option<::protobuf::Chars>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadEventCompleted {
    fn default() -> &'a ReadEventCompleted {
        <ReadEventCompleted as ::protobuf::Message>::default_instance()
    }
}

impl ReadEventCompleted {
    pub fn new() -> ReadEventCompleted {
        ::std::default::Default::default()
    }

    // required .EventStore.Client.Messages.ReadEventCompleted.ReadEventResult result = 1;


    pub fn get_result(&self) -> ReadEventCompleted_ReadEventResult {
        self.result.unwrap_or(ReadEventCompleted_ReadEventResult::Success)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ReadEventCompleted_ReadEventResult) {
        self.result = ::std::option::Option::Some(v);
    }

    // required .EventStore.Client.Messages.ResolvedIndexedEvent event = 2;


    pub fn get_event(&self) -> &ResolvedIndexedEvent {
        self.event.as_ref().unwrap_or_else(|| ResolvedIndexedEvent::default_instance())
    }
    pub fn clear_event(&mut self) {
        self.event.clear();
    }

    pub fn has_event(&self) -> bool {
        self.event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event(&mut self, v: ResolvedIndexedEvent) {
        self.event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event(&mut self) -> &mut ResolvedIndexedEvent {
        if self.event.is_none() {
            self.event.set_default();
        }
        self.event.as_mut().unwrap()
    }

    // Take field
    pub fn take_event(&mut self) -> ResolvedIndexedEvent {
        self.event.take().unwrap_or_else(|| ResolvedIndexedEvent::new())
    }

    // optional string error = 3;


    pub fn get_error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::protobuf::Chars) {
        self.error = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::protobuf::Chars {
        if self.error.is_none() {
            self.error = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::protobuf::Chars {
        self.error.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for ReadEventCompleted {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        if self.event.is_none() {
            return false;
        }
        for v in &self.event {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.event)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.event.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadEventCompleted {
        ReadEventCompleted::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ReadEventCompleted_ReadEventResult>>(
                    "result",
                    |m: &ReadEventCompleted| { &m.result },
                    |m: &mut ReadEventCompleted| { &mut m.result },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResolvedIndexedEvent>>(
                    "event",
                    |m: &ReadEventCompleted| { &m.event },
                    |m: &mut ReadEventCompleted| { &mut m.event },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "error",
                    |m: &ReadEventCompleted| { &m.error },
                    |m: &mut ReadEventCompleted| { &mut m.error },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReadEventCompleted>(
                    "ReadEventCompleted",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReadEventCompleted {
        static mut instance: ::protobuf::lazy::Lazy<ReadEventCompleted> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReadEventCompleted,
        };
        unsafe {
            instance.get(ReadEventCompleted::new)
        }
    }
}

impl ::protobuf::Clear for ReadEventCompleted {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.event.clear();
        self.error = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadEventCompleted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadEventCompleted {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ReadEventCompleted_ReadEventResult {
    Success = 0,
    NotFound = 1,
    NoStream = 2,
    StreamDeleted = 3,
    Error = 4,
    AccessDenied = 5,
}

impl ::protobuf::ProtobufEnum for ReadEventCompleted_ReadEventResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReadEventCompleted_ReadEventResult> {
        match value {
            0 => ::std::option::Option::Some(ReadEventCompleted_ReadEventResult::Success),
            1 => ::std::option::Option::Some(ReadEventCompleted_ReadEventResult::NotFound),
            2 => ::std::option::Option::Some(ReadEventCompleted_ReadEventResult::NoStream),
            3 => ::std::option::Option::Some(ReadEventCompleted_ReadEventResult::StreamDeleted),
            4 => ::std::option::Option::Some(ReadEventCompleted_ReadEventResult::Error),
            5 => ::std::option::Option::Some(ReadEventCompleted_ReadEventResult::AccessDenied),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ReadEventCompleted_ReadEventResult] = &[
            ReadEventCompleted_ReadEventResult::Success,
            ReadEventCompleted_ReadEventResult::NotFound,
            ReadEventCompleted_ReadEventResult::NoStream,
            ReadEventCompleted_ReadEventResult::StreamDeleted,
            ReadEventCompleted_ReadEventResult::Error,
            ReadEventCompleted_ReadEventResult::AccessDenied,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ReadEventCompleted_ReadEventResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ReadEventCompleted_ReadEventResult {
}

impl ::std::default::Default for ReadEventCompleted_ReadEventResult {
    fn default() -> Self {
        ReadEventCompleted_ReadEventResult::Success
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadEventCompleted_ReadEventResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadStreamEvents {
    // message fields
    event_stream_id: ::std::option::Option<::protobuf::Chars>,
    from_event_number: ::std::option::Option<i64>,
    max_count: ::std::option::Option<i32>,
    resolve_link_tos: ::std::option::Option<bool>,
    require_master: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadStreamEvents {
    fn default() -> &'a ReadStreamEvents {
        <ReadStreamEvents as ::protobuf::Message>::default_instance()
    }
}

impl ReadStreamEvents {
    pub fn new() -> ReadStreamEvents {
        ::std::default::Default::default()
    }

    // required string event_stream_id = 1;


    pub fn get_event_stream_id(&self) -> &str {
        match self.event_stream_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_event_stream_id(&mut self) {
        self.event_stream_id = ::std::option::Option::None;
    }

    pub fn has_event_stream_id(&self) -> bool {
        self.event_stream_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stream_id(&mut self, v: ::protobuf::Chars) {
        self.event_stream_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_stream_id(&mut self) -> &mut ::protobuf::Chars {
        if self.event_stream_id.is_none() {
            self.event_stream_id = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.event_stream_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_stream_id(&mut self) -> ::protobuf::Chars {
        self.event_stream_id.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // required int64 from_event_number = 2;


    pub fn get_from_event_number(&self) -> i64 {
        self.from_event_number.unwrap_or(0)
    }
    pub fn clear_from_event_number(&mut self) {
        self.from_event_number = ::std::option::Option::None;
    }

    pub fn has_from_event_number(&self) -> bool {
        self.from_event_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_event_number(&mut self, v: i64) {
        self.from_event_number = ::std::option::Option::Some(v);
    }

    // required int32 max_count = 3;


    pub fn get_max_count(&self) -> i32 {
        self.max_count.unwrap_or(0)
    }
    pub fn clear_max_count(&mut self) {
        self.max_count = ::std::option::Option::None;
    }

    pub fn has_max_count(&self) -> bool {
        self.max_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_count(&mut self, v: i32) {
        self.max_count = ::std::option::Option::Some(v);
    }

    // required bool resolve_link_tos = 4;


    pub fn get_resolve_link_tos(&self) -> bool {
        self.resolve_link_tos.unwrap_or(false)
    }
    pub fn clear_resolve_link_tos(&mut self) {
        self.resolve_link_tos = ::std::option::Option::None;
    }

    pub fn has_resolve_link_tos(&self) -> bool {
        self.resolve_link_tos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resolve_link_tos(&mut self, v: bool) {
        self.resolve_link_tos = ::std::option::Option::Some(v);
    }

    // required bool require_master = 5;


    pub fn get_require_master(&self) -> bool {
        self.require_master.unwrap_or(false)
    }
    pub fn clear_require_master(&mut self) {
        self.require_master = ::std::option::Option::None;
    }

    pub fn has_require_master(&self) -> bool {
        self.require_master.is_some()
    }

    // Param is passed by value, moved
    pub fn set_require_master(&mut self, v: bool) {
        self.require_master = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ReadStreamEvents {
    fn is_initialized(&self) -> bool {
        if self.event_stream_id.is_none() {
            return false;
        }
        if self.from_event_number.is_none() {
            return false;
        }
        if self.max_count.is_none() {
            return false;
        }
        if self.resolve_link_tos.is_none() {
            return false;
        }
        if self.require_master.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.event_stream_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.from_event_number = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_count = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.resolve_link_tos = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.require_master = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.event_stream_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.from_event_number {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.resolve_link_tos {
            my_size += 2;
        }
        if let Some(v) = self.require_master {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.event_stream_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.from_event_number {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.max_count {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.resolve_link_tos {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.require_master {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadStreamEvents {
        ReadStreamEvents::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "event_stream_id",
                    |m: &ReadStreamEvents| { &m.event_stream_id },
                    |m: &mut ReadStreamEvents| { &mut m.event_stream_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "from_event_number",
                    |m: &ReadStreamEvents| { &m.from_event_number },
                    |m: &mut ReadStreamEvents| { &mut m.from_event_number },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "max_count",
                    |m: &ReadStreamEvents| { &m.max_count },
                    |m: &mut ReadStreamEvents| { &mut m.max_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "resolve_link_tos",
                    |m: &ReadStreamEvents| { &m.resolve_link_tos },
                    |m: &mut ReadStreamEvents| { &mut m.resolve_link_tos },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "require_master",
                    |m: &ReadStreamEvents| { &m.require_master },
                    |m: &mut ReadStreamEvents| { &mut m.require_master },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReadStreamEvents>(
                    "ReadStreamEvents",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReadStreamEvents {
        static mut instance: ::protobuf::lazy::Lazy<ReadStreamEvents> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReadStreamEvents,
        };
        unsafe {
            instance.get(ReadStreamEvents::new)
        }
    }
}

impl ::protobuf::Clear for ReadStreamEvents {
    fn clear(&mut self) {
        self.event_stream_id = ::std::option::Option::None;
        self.from_event_number = ::std::option::Option::None;
        self.max_count = ::std::option::Option::None;
        self.resolve_link_tos = ::std::option::Option::None;
        self.require_master = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadStreamEvents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadStreamEvents {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadStreamEventsCompleted {
    // message fields
    events: ::protobuf::RepeatedField<ResolvedIndexedEvent>,
    result: ::std::option::Option<ReadStreamEventsCompleted_ReadStreamResult>,
    next_event_number: ::std::option::Option<i64>,
    last_event_number: ::std::option::Option<i64>,
    is_end_of_stream: ::std::option::Option<bool>,
    last_commit_position: ::std::option::Option<i64>,
    error: ::std::option::Option<::protobuf::Chars>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadStreamEventsCompleted {
    fn default() -> &'a ReadStreamEventsCompleted {
        <ReadStreamEventsCompleted as ::protobuf::Message>::default_instance()
    }
}

impl ReadStreamEventsCompleted {
    pub fn new() -> ReadStreamEventsCompleted {
        ::std::default::Default::default()
    }

    // repeated .EventStore.Client.Messages.ResolvedIndexedEvent events = 1;


    pub fn get_events(&self) -> &[ResolvedIndexedEvent] {
        &self.events
    }
    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::protobuf::RepeatedField<ResolvedIndexedEvent>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events(&mut self) -> &mut ::protobuf::RepeatedField<ResolvedIndexedEvent> {
        &mut self.events
    }

    // Take field
    pub fn take_events(&mut self) -> ::protobuf::RepeatedField<ResolvedIndexedEvent> {
        ::std::mem::replace(&mut self.events, ::protobuf::RepeatedField::new())
    }

    // required .EventStore.Client.Messages.ReadStreamEventsCompleted.ReadStreamResult result = 2;


    pub fn get_result(&self) -> ReadStreamEventsCompleted_ReadStreamResult {
        self.result.unwrap_or(ReadStreamEventsCompleted_ReadStreamResult::Success)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ReadStreamEventsCompleted_ReadStreamResult) {
        self.result = ::std::option::Option::Some(v);
    }

    // required int64 next_event_number = 3;


    pub fn get_next_event_number(&self) -> i64 {
        self.next_event_number.unwrap_or(0)
    }
    pub fn clear_next_event_number(&mut self) {
        self.next_event_number = ::std::option::Option::None;
    }

    pub fn has_next_event_number(&self) -> bool {
        self.next_event_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_event_number(&mut self, v: i64) {
        self.next_event_number = ::std::option::Option::Some(v);
    }

    // required int64 last_event_number = 4;


    pub fn get_last_event_number(&self) -> i64 {
        self.last_event_number.unwrap_or(0)
    }
    pub fn clear_last_event_number(&mut self) {
        self.last_event_number = ::std::option::Option::None;
    }

    pub fn has_last_event_number(&self) -> bool {
        self.last_event_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_event_number(&mut self, v: i64) {
        self.last_event_number = ::std::option::Option::Some(v);
    }

    // required bool is_end_of_stream = 5;


    pub fn get_is_end_of_stream(&self) -> bool {
        self.is_end_of_stream.unwrap_or(false)
    }
    pub fn clear_is_end_of_stream(&mut self) {
        self.is_end_of_stream = ::std::option::Option::None;
    }

    pub fn has_is_end_of_stream(&self) -> bool {
        self.is_end_of_stream.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_end_of_stream(&mut self, v: bool) {
        self.is_end_of_stream = ::std::option::Option::Some(v);
    }

    // required int64 last_commit_position = 6;


    pub fn get_last_commit_position(&self) -> i64 {
        self.last_commit_position.unwrap_or(0)
    }
    pub fn clear_last_commit_position(&mut self) {
        self.last_commit_position = ::std::option::Option::None;
    }

    pub fn has_last_commit_position(&self) -> bool {
        self.last_commit_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_commit_position(&mut self, v: i64) {
        self.last_commit_position = ::std::option::Option::Some(v);
    }

    // optional string error = 7;


    pub fn get_error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::protobuf::Chars) {
        self.error = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::protobuf::Chars {
        if self.error.is_none() {
            self.error = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::protobuf::Chars {
        self.error.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for ReadStreamEventsCompleted {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        if self.next_event_number.is_none() {
            return false;
        }
        if self.last_event_number.is_none() {
            return false;
        }
        if self.is_end_of_stream.is_none() {
            return false;
        }
        if self.last_commit_position.is_none() {
            return false;
        }
        for v in &self.events {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.events)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.next_event_number = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.last_event_number = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_end_of_stream = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.last_commit_position = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.next_event_number {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_event_number {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_end_of_stream {
            my_size += 2;
        }
        if let Some(v) = self.last_commit_position {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.events {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.result {
            os.write_enum(2, v.value())?;
        }
        if let Some(v) = self.next_event_number {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.last_event_number {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.is_end_of_stream {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.last_commit_position {
            os.write_int64(6, v)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadStreamEventsCompleted {
        ReadStreamEventsCompleted::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResolvedIndexedEvent>>(
                    "events",
                    |m: &ReadStreamEventsCompleted| { &m.events },
                    |m: &mut ReadStreamEventsCompleted| { &mut m.events },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ReadStreamEventsCompleted_ReadStreamResult>>(
                    "result",
                    |m: &ReadStreamEventsCompleted| { &m.result },
                    |m: &mut ReadStreamEventsCompleted| { &mut m.result },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "next_event_number",
                    |m: &ReadStreamEventsCompleted| { &m.next_event_number },
                    |m: &mut ReadStreamEventsCompleted| { &mut m.next_event_number },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "last_event_number",
                    |m: &ReadStreamEventsCompleted| { &m.last_event_number },
                    |m: &mut ReadStreamEventsCompleted| { &mut m.last_event_number },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_end_of_stream",
                    |m: &ReadStreamEventsCompleted| { &m.is_end_of_stream },
                    |m: &mut ReadStreamEventsCompleted| { &mut m.is_end_of_stream },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "last_commit_position",
                    |m: &ReadStreamEventsCompleted| { &m.last_commit_position },
                    |m: &mut ReadStreamEventsCompleted| { &mut m.last_commit_position },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "error",
                    |m: &ReadStreamEventsCompleted| { &m.error },
                    |m: &mut ReadStreamEventsCompleted| { &mut m.error },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReadStreamEventsCompleted>(
                    "ReadStreamEventsCompleted",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReadStreamEventsCompleted {
        static mut instance: ::protobuf::lazy::Lazy<ReadStreamEventsCompleted> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReadStreamEventsCompleted,
        };
        unsafe {
            instance.get(ReadStreamEventsCompleted::new)
        }
    }
}

impl ::protobuf::Clear for ReadStreamEventsCompleted {
    fn clear(&mut self) {
        self.events.clear();
        self.result = ::std::option::Option::None;
        self.next_event_number = ::std::option::Option::None;
        self.last_event_number = ::std::option::Option::None;
        self.is_end_of_stream = ::std::option::Option::None;
        self.last_commit_position = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadStreamEventsCompleted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadStreamEventsCompleted {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ReadStreamEventsCompleted_ReadStreamResult {
    Success = 0,
    NoStream = 1,
    StreamDeleted = 2,
    NotModified = 3,
    Error = 4,
    AccessDenied = 5,
}

impl ::protobuf::ProtobufEnum for ReadStreamEventsCompleted_ReadStreamResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReadStreamEventsCompleted_ReadStreamResult> {
        match value {
            0 => ::std::option::Option::Some(ReadStreamEventsCompleted_ReadStreamResult::Success),
            1 => ::std::option::Option::Some(ReadStreamEventsCompleted_ReadStreamResult::NoStream),
            2 => ::std::option::Option::Some(ReadStreamEventsCompleted_ReadStreamResult::StreamDeleted),
            3 => ::std::option::Option::Some(ReadStreamEventsCompleted_ReadStreamResult::NotModified),
            4 => ::std::option::Option::Some(ReadStreamEventsCompleted_ReadStreamResult::Error),
            5 => ::std::option::Option::Some(ReadStreamEventsCompleted_ReadStreamResult::AccessDenied),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ReadStreamEventsCompleted_ReadStreamResult] = &[
            ReadStreamEventsCompleted_ReadStreamResult::Success,
            ReadStreamEventsCompleted_ReadStreamResult::NoStream,
            ReadStreamEventsCompleted_ReadStreamResult::StreamDeleted,
            ReadStreamEventsCompleted_ReadStreamResult::NotModified,
            ReadStreamEventsCompleted_ReadStreamResult::Error,
            ReadStreamEventsCompleted_ReadStreamResult::AccessDenied,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ReadStreamEventsCompleted_ReadStreamResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ReadStreamEventsCompleted_ReadStreamResult {
}

impl ::std::default::Default for ReadStreamEventsCompleted_ReadStreamResult {
    fn default() -> Self {
        ReadStreamEventsCompleted_ReadStreamResult::Success
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadStreamEventsCompleted_ReadStreamResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadAllEvents {
    // message fields
    commit_position: ::std::option::Option<i64>,
    prepare_position: ::std::option::Option<i64>,
    max_count: ::std::option::Option<i32>,
    resolve_link_tos: ::std::option::Option<bool>,
    require_master: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadAllEvents {
    fn default() -> &'a ReadAllEvents {
        <ReadAllEvents as ::protobuf::Message>::default_instance()
    }
}

impl ReadAllEvents {
    pub fn new() -> ReadAllEvents {
        ::std::default::Default::default()
    }

    // required int64 commit_position = 1;


    pub fn get_commit_position(&self) -> i64 {
        self.commit_position.unwrap_or(0)
    }
    pub fn clear_commit_position(&mut self) {
        self.commit_position = ::std::option::Option::None;
    }

    pub fn has_commit_position(&self) -> bool {
        self.commit_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commit_position(&mut self, v: i64) {
        self.commit_position = ::std::option::Option::Some(v);
    }

    // required int64 prepare_position = 2;


    pub fn get_prepare_position(&self) -> i64 {
        self.prepare_position.unwrap_or(0)
    }
    pub fn clear_prepare_position(&mut self) {
        self.prepare_position = ::std::option::Option::None;
    }

    pub fn has_prepare_position(&self) -> bool {
        self.prepare_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prepare_position(&mut self, v: i64) {
        self.prepare_position = ::std::option::Option::Some(v);
    }

    // required int32 max_count = 3;


    pub fn get_max_count(&self) -> i32 {
        self.max_count.unwrap_or(0)
    }
    pub fn clear_max_count(&mut self) {
        self.max_count = ::std::option::Option::None;
    }

    pub fn has_max_count(&self) -> bool {
        self.max_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_count(&mut self, v: i32) {
        self.max_count = ::std::option::Option::Some(v);
    }

    // required bool resolve_link_tos = 4;


    pub fn get_resolve_link_tos(&self) -> bool {
        self.resolve_link_tos.unwrap_or(false)
    }
    pub fn clear_resolve_link_tos(&mut self) {
        self.resolve_link_tos = ::std::option::Option::None;
    }

    pub fn has_resolve_link_tos(&self) -> bool {
        self.resolve_link_tos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resolve_link_tos(&mut self, v: bool) {
        self.resolve_link_tos = ::std::option::Option::Some(v);
    }

    // required bool require_master = 5;


    pub fn get_require_master(&self) -> bool {
        self.require_master.unwrap_or(false)
    }
    pub fn clear_require_master(&mut self) {
        self.require_master = ::std::option::Option::None;
    }

    pub fn has_require_master(&self) -> bool {
        self.require_master.is_some()
    }

    // Param is passed by value, moved
    pub fn set_require_master(&mut self, v: bool) {
        self.require_master = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ReadAllEvents {
    fn is_initialized(&self) -> bool {
        if self.commit_position.is_none() {
            return false;
        }
        if self.prepare_position.is_none() {
            return false;
        }
        if self.max_count.is_none() {
            return false;
        }
        if self.resolve_link_tos.is_none() {
            return false;
        }
        if self.require_master.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.commit_position = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.prepare_position = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_count = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.resolve_link_tos = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.require_master = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.commit_position {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prepare_position {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.resolve_link_tos {
            my_size += 2;
        }
        if let Some(v) = self.require_master {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.commit_position {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.prepare_position {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.max_count {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.resolve_link_tos {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.require_master {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadAllEvents {
        ReadAllEvents::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "commit_position",
                    |m: &ReadAllEvents| { &m.commit_position },
                    |m: &mut ReadAllEvents| { &mut m.commit_position },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "prepare_position",
                    |m: &ReadAllEvents| { &m.prepare_position },
                    |m: &mut ReadAllEvents| { &mut m.prepare_position },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "max_count",
                    |m: &ReadAllEvents| { &m.max_count },
                    |m: &mut ReadAllEvents| { &mut m.max_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "resolve_link_tos",
                    |m: &ReadAllEvents| { &m.resolve_link_tos },
                    |m: &mut ReadAllEvents| { &mut m.resolve_link_tos },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "require_master",
                    |m: &ReadAllEvents| { &m.require_master },
                    |m: &mut ReadAllEvents| { &mut m.require_master },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReadAllEvents>(
                    "ReadAllEvents",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReadAllEvents {
        static mut instance: ::protobuf::lazy::Lazy<ReadAllEvents> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReadAllEvents,
        };
        unsafe {
            instance.get(ReadAllEvents::new)
        }
    }
}

impl ::protobuf::Clear for ReadAllEvents {
    fn clear(&mut self) {
        self.commit_position = ::std::option::Option::None;
        self.prepare_position = ::std::option::Option::None;
        self.max_count = ::std::option::Option::None;
        self.resolve_link_tos = ::std::option::Option::None;
        self.require_master = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadAllEvents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadAllEvents {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadAllEventsCompleted {
    // message fields
    commit_position: ::std::option::Option<i64>,
    prepare_position: ::std::option::Option<i64>,
    events: ::protobuf::RepeatedField<ResolvedEvent>,
    next_commit_position: ::std::option::Option<i64>,
    next_prepare_position: ::std::option::Option<i64>,
    result: ::std::option::Option<ReadAllEventsCompleted_ReadAllResult>,
    error: ::std::option::Option<::protobuf::Chars>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadAllEventsCompleted {
    fn default() -> &'a ReadAllEventsCompleted {
        <ReadAllEventsCompleted as ::protobuf::Message>::default_instance()
    }
}

impl ReadAllEventsCompleted {
    pub fn new() -> ReadAllEventsCompleted {
        ::std::default::Default::default()
    }

    // required int64 commit_position = 1;


    pub fn get_commit_position(&self) -> i64 {
        self.commit_position.unwrap_or(0)
    }
    pub fn clear_commit_position(&mut self) {
        self.commit_position = ::std::option::Option::None;
    }

    pub fn has_commit_position(&self) -> bool {
        self.commit_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commit_position(&mut self, v: i64) {
        self.commit_position = ::std::option::Option::Some(v);
    }

    // required int64 prepare_position = 2;


    pub fn get_prepare_position(&self) -> i64 {
        self.prepare_position.unwrap_or(0)
    }
    pub fn clear_prepare_position(&mut self) {
        self.prepare_position = ::std::option::Option::None;
    }

    pub fn has_prepare_position(&self) -> bool {
        self.prepare_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prepare_position(&mut self, v: i64) {
        self.prepare_position = ::std::option::Option::Some(v);
    }

    // repeated .EventStore.Client.Messages.ResolvedEvent events = 3;


    pub fn get_events(&self) -> &[ResolvedEvent] {
        &self.events
    }
    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::protobuf::RepeatedField<ResolvedEvent>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events(&mut self) -> &mut ::protobuf::RepeatedField<ResolvedEvent> {
        &mut self.events
    }

    // Take field
    pub fn take_events(&mut self) -> ::protobuf::RepeatedField<ResolvedEvent> {
        ::std::mem::replace(&mut self.events, ::protobuf::RepeatedField::new())
    }

    // required int64 next_commit_position = 4;


    pub fn get_next_commit_position(&self) -> i64 {
        self.next_commit_position.unwrap_or(0)
    }
    pub fn clear_next_commit_position(&mut self) {
        self.next_commit_position = ::std::option::Option::None;
    }

    pub fn has_next_commit_position(&self) -> bool {
        self.next_commit_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_commit_position(&mut self, v: i64) {
        self.next_commit_position = ::std::option::Option::Some(v);
    }

    // required int64 next_prepare_position = 5;


    pub fn get_next_prepare_position(&self) -> i64 {
        self.next_prepare_position.unwrap_or(0)
    }
    pub fn clear_next_prepare_position(&mut self) {
        self.next_prepare_position = ::std::option::Option::None;
    }

    pub fn has_next_prepare_position(&self) -> bool {
        self.next_prepare_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_prepare_position(&mut self, v: i64) {
        self.next_prepare_position = ::std::option::Option::Some(v);
    }

    // optional .EventStore.Client.Messages.ReadAllEventsCompleted.ReadAllResult result = 6;


    pub fn get_result(&self) -> ReadAllEventsCompleted_ReadAllResult {
        self.result.unwrap_or(ReadAllEventsCompleted_ReadAllResult::Success)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ReadAllEventsCompleted_ReadAllResult) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional string error = 7;


    pub fn get_error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::protobuf::Chars) {
        self.error = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::protobuf::Chars {
        if self.error.is_none() {
            self.error = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::protobuf::Chars {
        self.error.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for ReadAllEventsCompleted {
    fn is_initialized(&self) -> bool {
        if self.commit_position.is_none() {
            return false;
        }
        if self.prepare_position.is_none() {
            return false;
        }
        if self.next_commit_position.is_none() {
            return false;
        }
        if self.next_prepare_position.is_none() {
            return false;
        }
        for v in &self.events {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.commit_position = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.prepare_position = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.events)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.next_commit_position = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.next_prepare_position = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 6, &mut self.unknown_fields)?
                },
                7 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.commit_position {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prepare_position {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.next_commit_position {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.next_prepare_position {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(6, v);
        }
        if let Some(ref v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.commit_position {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.prepare_position {
            os.write_int64(2, v)?;
        }
        for v in &self.events {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.next_commit_position {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.next_prepare_position {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.result {
            os.write_enum(6, v.value())?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadAllEventsCompleted {
        ReadAllEventsCompleted::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "commit_position",
                    |m: &ReadAllEventsCompleted| { &m.commit_position },
                    |m: &mut ReadAllEventsCompleted| { &mut m.commit_position },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "prepare_position",
                    |m: &ReadAllEventsCompleted| { &m.prepare_position },
                    |m: &mut ReadAllEventsCompleted| { &mut m.prepare_position },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResolvedEvent>>(
                    "events",
                    |m: &ReadAllEventsCompleted| { &m.events },
                    |m: &mut ReadAllEventsCompleted| { &mut m.events },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "next_commit_position",
                    |m: &ReadAllEventsCompleted| { &m.next_commit_position },
                    |m: &mut ReadAllEventsCompleted| { &mut m.next_commit_position },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "next_prepare_position",
                    |m: &ReadAllEventsCompleted| { &m.next_prepare_position },
                    |m: &mut ReadAllEventsCompleted| { &mut m.next_prepare_position },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ReadAllEventsCompleted_ReadAllResult>>(
                    "result",
                    |m: &ReadAllEventsCompleted| { &m.result },
                    |m: &mut ReadAllEventsCompleted| { &mut m.result },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "error",
                    |m: &ReadAllEventsCompleted| { &m.error },
                    |m: &mut ReadAllEventsCompleted| { &mut m.error },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReadAllEventsCompleted>(
                    "ReadAllEventsCompleted",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReadAllEventsCompleted {
        static mut instance: ::protobuf::lazy::Lazy<ReadAllEventsCompleted> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReadAllEventsCompleted,
        };
        unsafe {
            instance.get(ReadAllEventsCompleted::new)
        }
    }
}

impl ::protobuf::Clear for ReadAllEventsCompleted {
    fn clear(&mut self) {
        self.commit_position = ::std::option::Option::None;
        self.prepare_position = ::std::option::Option::None;
        self.events.clear();
        self.next_commit_position = ::std::option::Option::None;
        self.next_prepare_position = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadAllEventsCompleted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadAllEventsCompleted {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ReadAllEventsCompleted_ReadAllResult {
    Success = 0,
    NotModified = 1,
    Error = 2,
    AccessDenied = 3,
}

impl ::protobuf::ProtobufEnum for ReadAllEventsCompleted_ReadAllResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReadAllEventsCompleted_ReadAllResult> {
        match value {
            0 => ::std::option::Option::Some(ReadAllEventsCompleted_ReadAllResult::Success),
            1 => ::std::option::Option::Some(ReadAllEventsCompleted_ReadAllResult::NotModified),
            2 => ::std::option::Option::Some(ReadAllEventsCompleted_ReadAllResult::Error),
            3 => ::std::option::Option::Some(ReadAllEventsCompleted_ReadAllResult::AccessDenied),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ReadAllEventsCompleted_ReadAllResult] = &[
            ReadAllEventsCompleted_ReadAllResult::Success,
            ReadAllEventsCompleted_ReadAllResult::NotModified,
            ReadAllEventsCompleted_ReadAllResult::Error,
            ReadAllEventsCompleted_ReadAllResult::AccessDenied,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ReadAllEventsCompleted_ReadAllResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ReadAllEventsCompleted_ReadAllResult {
}

impl ::std::default::Default for ReadAllEventsCompleted_ReadAllResult {
    fn default() -> Self {
        ReadAllEventsCompleted_ReadAllResult::Success
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadAllEventsCompleted_ReadAllResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreatePersistentSubscription {
    // message fields
    subscription_group_name: ::std::option::Option<::protobuf::Chars>,
    event_stream_id: ::std::option::Option<::protobuf::Chars>,
    resolve_link_tos: ::std::option::Option<bool>,
    start_from: ::std::option::Option<i64>,
    message_timeout_milliseconds: ::std::option::Option<i32>,
    record_statistics: ::std::option::Option<bool>,
    live_buffer_size: ::std::option::Option<i32>,
    read_batch_size: ::std::option::Option<i32>,
    buffer_size: ::std::option::Option<i32>,
    max_retry_count: ::std::option::Option<i32>,
    prefer_round_robin: ::std::option::Option<bool>,
    checkpoint_after_time: ::std::option::Option<i32>,
    checkpoint_max_count: ::std::option::Option<i32>,
    checkpoint_min_count: ::std::option::Option<i32>,
    subscriber_max_count: ::std::option::Option<i32>,
    named_consumer_strategy: ::std::option::Option<::protobuf::Chars>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreatePersistentSubscription {
    fn default() -> &'a CreatePersistentSubscription {
        <CreatePersistentSubscription as ::protobuf::Message>::default_instance()
    }
}

impl CreatePersistentSubscription {
    pub fn new() -> CreatePersistentSubscription {
        ::std::default::Default::default()
    }

    // required string subscription_group_name = 1;


    pub fn get_subscription_group_name(&self) -> &str {
        match self.subscription_group_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_subscription_group_name(&mut self) {
        self.subscription_group_name = ::std::option::Option::None;
    }

    pub fn has_subscription_group_name(&self) -> bool {
        self.subscription_group_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscription_group_name(&mut self, v: ::protobuf::Chars) {
        self.subscription_group_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription_group_name(&mut self) -> &mut ::protobuf::Chars {
        if self.subscription_group_name.is_none() {
            self.subscription_group_name = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.subscription_group_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_subscription_group_name(&mut self) -> ::protobuf::Chars {
        self.subscription_group_name.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // required string event_stream_id = 2;


    pub fn get_event_stream_id(&self) -> &str {
        match self.event_stream_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_event_stream_id(&mut self) {
        self.event_stream_id = ::std::option::Option::None;
    }

    pub fn has_event_stream_id(&self) -> bool {
        self.event_stream_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stream_id(&mut self, v: ::protobuf::Chars) {
        self.event_stream_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_stream_id(&mut self) -> &mut ::protobuf::Chars {
        if self.event_stream_id.is_none() {
            self.event_stream_id = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.event_stream_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_stream_id(&mut self) -> ::protobuf::Chars {
        self.event_stream_id.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // required bool resolve_link_tos = 3;


    pub fn get_resolve_link_tos(&self) -> bool {
        self.resolve_link_tos.unwrap_or(false)
    }
    pub fn clear_resolve_link_tos(&mut self) {
        self.resolve_link_tos = ::std::option::Option::None;
    }

    pub fn has_resolve_link_tos(&self) -> bool {
        self.resolve_link_tos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resolve_link_tos(&mut self, v: bool) {
        self.resolve_link_tos = ::std::option::Option::Some(v);
    }

    // required int64 start_from = 4;


    pub fn get_start_from(&self) -> i64 {
        self.start_from.unwrap_or(0)
    }
    pub fn clear_start_from(&mut self) {
        self.start_from = ::std::option::Option::None;
    }

    pub fn has_start_from(&self) -> bool {
        self.start_from.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_from(&mut self, v: i64) {
        self.start_from = ::std::option::Option::Some(v);
    }

    // required int32 message_timeout_milliseconds = 5;


    pub fn get_message_timeout_milliseconds(&self) -> i32 {
        self.message_timeout_milliseconds.unwrap_or(0)
    }
    pub fn clear_message_timeout_milliseconds(&mut self) {
        self.message_timeout_milliseconds = ::std::option::Option::None;
    }

    pub fn has_message_timeout_milliseconds(&self) -> bool {
        self.message_timeout_milliseconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_timeout_milliseconds(&mut self, v: i32) {
        self.message_timeout_milliseconds = ::std::option::Option::Some(v);
    }

    // required bool record_statistics = 6;


    pub fn get_record_statistics(&self) -> bool {
        self.record_statistics.unwrap_or(false)
    }
    pub fn clear_record_statistics(&mut self) {
        self.record_statistics = ::std::option::Option::None;
    }

    pub fn has_record_statistics(&self) -> bool {
        self.record_statistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_record_statistics(&mut self, v: bool) {
        self.record_statistics = ::std::option::Option::Some(v);
    }

    // required int32 live_buffer_size = 7;


    pub fn get_live_buffer_size(&self) -> i32 {
        self.live_buffer_size.unwrap_or(0)
    }
    pub fn clear_live_buffer_size(&mut self) {
        self.live_buffer_size = ::std::option::Option::None;
    }

    pub fn has_live_buffer_size(&self) -> bool {
        self.live_buffer_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_live_buffer_size(&mut self, v: i32) {
        self.live_buffer_size = ::std::option::Option::Some(v);
    }

    // required int32 read_batch_size = 8;


    pub fn get_read_batch_size(&self) -> i32 {
        self.read_batch_size.unwrap_or(0)
    }
    pub fn clear_read_batch_size(&mut self) {
        self.read_batch_size = ::std::option::Option::None;
    }

    pub fn has_read_batch_size(&self) -> bool {
        self.read_batch_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read_batch_size(&mut self, v: i32) {
        self.read_batch_size = ::std::option::Option::Some(v);
    }

    // required int32 buffer_size = 9;


    pub fn get_buffer_size(&self) -> i32 {
        self.buffer_size.unwrap_or(0)
    }
    pub fn clear_buffer_size(&mut self) {
        self.buffer_size = ::std::option::Option::None;
    }

    pub fn has_buffer_size(&self) -> bool {
        self.buffer_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buffer_size(&mut self, v: i32) {
        self.buffer_size = ::std::option::Option::Some(v);
    }

    // required int32 max_retry_count = 10;


    pub fn get_max_retry_count(&self) -> i32 {
        self.max_retry_count.unwrap_or(0)
    }
    pub fn clear_max_retry_count(&mut self) {
        self.max_retry_count = ::std::option::Option::None;
    }

    pub fn has_max_retry_count(&self) -> bool {
        self.max_retry_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_retry_count(&mut self, v: i32) {
        self.max_retry_count = ::std::option::Option::Some(v);
    }

    // required bool prefer_round_robin = 11;


    pub fn get_prefer_round_robin(&self) -> bool {
        self.prefer_round_robin.unwrap_or(false)
    }
    pub fn clear_prefer_round_robin(&mut self) {
        self.prefer_round_robin = ::std::option::Option::None;
    }

    pub fn has_prefer_round_robin(&self) -> bool {
        self.prefer_round_robin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prefer_round_robin(&mut self, v: bool) {
        self.prefer_round_robin = ::std::option::Option::Some(v);
    }

    // required int32 checkpoint_after_time = 12;


    pub fn get_checkpoint_after_time(&self) -> i32 {
        self.checkpoint_after_time.unwrap_or(0)
    }
    pub fn clear_checkpoint_after_time(&mut self) {
        self.checkpoint_after_time = ::std::option::Option::None;
    }

    pub fn has_checkpoint_after_time(&self) -> bool {
        self.checkpoint_after_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checkpoint_after_time(&mut self, v: i32) {
        self.checkpoint_after_time = ::std::option::Option::Some(v);
    }

    // required int32 checkpoint_max_count = 13;


    pub fn get_checkpoint_max_count(&self) -> i32 {
        self.checkpoint_max_count.unwrap_or(0)
    }
    pub fn clear_checkpoint_max_count(&mut self) {
        self.checkpoint_max_count = ::std::option::Option::None;
    }

    pub fn has_checkpoint_max_count(&self) -> bool {
        self.checkpoint_max_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checkpoint_max_count(&mut self, v: i32) {
        self.checkpoint_max_count = ::std::option::Option::Some(v);
    }

    // required int32 checkpoint_min_count = 14;


    pub fn get_checkpoint_min_count(&self) -> i32 {
        self.checkpoint_min_count.unwrap_or(0)
    }
    pub fn clear_checkpoint_min_count(&mut self) {
        self.checkpoint_min_count = ::std::option::Option::None;
    }

    pub fn has_checkpoint_min_count(&self) -> bool {
        self.checkpoint_min_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checkpoint_min_count(&mut self, v: i32) {
        self.checkpoint_min_count = ::std::option::Option::Some(v);
    }

    // required int32 subscriber_max_count = 15;


    pub fn get_subscriber_max_count(&self) -> i32 {
        self.subscriber_max_count.unwrap_or(0)
    }
    pub fn clear_subscriber_max_count(&mut self) {
        self.subscriber_max_count = ::std::option::Option::None;
    }

    pub fn has_subscriber_max_count(&self) -> bool {
        self.subscriber_max_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscriber_max_count(&mut self, v: i32) {
        self.subscriber_max_count = ::std::option::Option::Some(v);
    }

    // optional string named_consumer_strategy = 16;


    pub fn get_named_consumer_strategy(&self) -> &str {
        match self.named_consumer_strategy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_named_consumer_strategy(&mut self) {
        self.named_consumer_strategy = ::std::option::Option::None;
    }

    pub fn has_named_consumer_strategy(&self) -> bool {
        self.named_consumer_strategy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_named_consumer_strategy(&mut self, v: ::protobuf::Chars) {
        self.named_consumer_strategy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_named_consumer_strategy(&mut self) -> &mut ::protobuf::Chars {
        if self.named_consumer_strategy.is_none() {
            self.named_consumer_strategy = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.named_consumer_strategy.as_mut().unwrap()
    }

    // Take field
    pub fn take_named_consumer_strategy(&mut self) -> ::protobuf::Chars {
        self.named_consumer_strategy.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for CreatePersistentSubscription {
    fn is_initialized(&self) -> bool {
        if self.subscription_group_name.is_none() {
            return false;
        }
        if self.event_stream_id.is_none() {
            return false;
        }
        if self.resolve_link_tos.is_none() {
            return false;
        }
        if self.start_from.is_none() {
            return false;
        }
        if self.message_timeout_milliseconds.is_none() {
            return false;
        }
        if self.record_statistics.is_none() {
            return false;
        }
        if self.live_buffer_size.is_none() {
            return false;
        }
        if self.read_batch_size.is_none() {
            return false;
        }
        if self.buffer_size.is_none() {
            return false;
        }
        if self.max_retry_count.is_none() {
            return false;
        }
        if self.prefer_round_robin.is_none() {
            return false;
        }
        if self.checkpoint_after_time.is_none() {
            return false;
        }
        if self.checkpoint_max_count.is_none() {
            return false;
        }
        if self.checkpoint_min_count.is_none() {
            return false;
        }
        if self.subscriber_max_count.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.subscription_group_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.event_stream_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.resolve_link_tos = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.start_from = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.message_timeout_milliseconds = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.record_statistics = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.live_buffer_size = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.read_batch_size = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.buffer_size = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_retry_count = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prefer_round_robin = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.checkpoint_after_time = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.checkpoint_max_count = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.checkpoint_min_count = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.subscriber_max_count = ::std::option::Option::Some(tmp);
                },
                16 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.named_consumer_strategy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.subscription_group_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.event_stream_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.resolve_link_tos {
            my_size += 2;
        }
        if let Some(v) = self.start_from {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.message_timeout_milliseconds {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.record_statistics {
            my_size += 2;
        }
        if let Some(v) = self.live_buffer_size {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.read_batch_size {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.buffer_size {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_retry_count {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prefer_round_robin {
            my_size += 2;
        }
        if let Some(v) = self.checkpoint_after_time {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.checkpoint_max_count {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.checkpoint_min_count {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.subscriber_max_count {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.named_consumer_strategy.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.subscription_group_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(ref v) = self.event_stream_id.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.resolve_link_tos {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.start_from {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.message_timeout_milliseconds {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.record_statistics {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.live_buffer_size {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.read_batch_size {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.buffer_size {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.max_retry_count {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.prefer_round_robin {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.checkpoint_after_time {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.checkpoint_max_count {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.checkpoint_min_count {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.subscriber_max_count {
            os.write_int32(15, v)?;
        }
        if let Some(ref v) = self.named_consumer_strategy.as_ref() {
            os.write_string(16, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreatePersistentSubscription {
        CreatePersistentSubscription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "subscription_group_name",
                    |m: &CreatePersistentSubscription| { &m.subscription_group_name },
                    |m: &mut CreatePersistentSubscription| { &mut m.subscription_group_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "event_stream_id",
                    |m: &CreatePersistentSubscription| { &m.event_stream_id },
                    |m: &mut CreatePersistentSubscription| { &mut m.event_stream_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "resolve_link_tos",
                    |m: &CreatePersistentSubscription| { &m.resolve_link_tos },
                    |m: &mut CreatePersistentSubscription| { &mut m.resolve_link_tos },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "start_from",
                    |m: &CreatePersistentSubscription| { &m.start_from },
                    |m: &mut CreatePersistentSubscription| { &mut m.start_from },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "message_timeout_milliseconds",
                    |m: &CreatePersistentSubscription| { &m.message_timeout_milliseconds },
                    |m: &mut CreatePersistentSubscription| { &mut m.message_timeout_milliseconds },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "record_statistics",
                    |m: &CreatePersistentSubscription| { &m.record_statistics },
                    |m: &mut CreatePersistentSubscription| { &mut m.record_statistics },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "live_buffer_size",
                    |m: &CreatePersistentSubscription| { &m.live_buffer_size },
                    |m: &mut CreatePersistentSubscription| { &mut m.live_buffer_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "read_batch_size",
                    |m: &CreatePersistentSubscription| { &m.read_batch_size },
                    |m: &mut CreatePersistentSubscription| { &mut m.read_batch_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "buffer_size",
                    |m: &CreatePersistentSubscription| { &m.buffer_size },
                    |m: &mut CreatePersistentSubscription| { &mut m.buffer_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "max_retry_count",
                    |m: &CreatePersistentSubscription| { &m.max_retry_count },
                    |m: &mut CreatePersistentSubscription| { &mut m.max_retry_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "prefer_round_robin",
                    |m: &CreatePersistentSubscription| { &m.prefer_round_robin },
                    |m: &mut CreatePersistentSubscription| { &mut m.prefer_round_robin },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "checkpoint_after_time",
                    |m: &CreatePersistentSubscription| { &m.checkpoint_after_time },
                    |m: &mut CreatePersistentSubscription| { &mut m.checkpoint_after_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "checkpoint_max_count",
                    |m: &CreatePersistentSubscription| { &m.checkpoint_max_count },
                    |m: &mut CreatePersistentSubscription| { &mut m.checkpoint_max_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "checkpoint_min_count",
                    |m: &CreatePersistentSubscription| { &m.checkpoint_min_count },
                    |m: &mut CreatePersistentSubscription| { &mut m.checkpoint_min_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "subscriber_max_count",
                    |m: &CreatePersistentSubscription| { &m.subscriber_max_count },
                    |m: &mut CreatePersistentSubscription| { &mut m.subscriber_max_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "named_consumer_strategy",
                    |m: &CreatePersistentSubscription| { &m.named_consumer_strategy },
                    |m: &mut CreatePersistentSubscription| { &mut m.named_consumer_strategy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreatePersistentSubscription>(
                    "CreatePersistentSubscription",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreatePersistentSubscription {
        static mut instance: ::protobuf::lazy::Lazy<CreatePersistentSubscription> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreatePersistentSubscription,
        };
        unsafe {
            instance.get(CreatePersistentSubscription::new)
        }
    }
}

impl ::protobuf::Clear for CreatePersistentSubscription {
    fn clear(&mut self) {
        self.subscription_group_name = ::std::option::Option::None;
        self.event_stream_id = ::std::option::Option::None;
        self.resolve_link_tos = ::std::option::Option::None;
        self.start_from = ::std::option::Option::None;
        self.message_timeout_milliseconds = ::std::option::Option::None;
        self.record_statistics = ::std::option::Option::None;
        self.live_buffer_size = ::std::option::Option::None;
        self.read_batch_size = ::std::option::Option::None;
        self.buffer_size = ::std::option::Option::None;
        self.max_retry_count = ::std::option::Option::None;
        self.prefer_round_robin = ::std::option::Option::None;
        self.checkpoint_after_time = ::std::option::Option::None;
        self.checkpoint_max_count = ::std::option::Option::None;
        self.checkpoint_min_count = ::std::option::Option::None;
        self.subscriber_max_count = ::std::option::Option::None;
        self.named_consumer_strategy = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreatePersistentSubscription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreatePersistentSubscription {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeletePersistentSubscription {
    // message fields
    subscription_group_name: ::std::option::Option<::protobuf::Chars>,
    event_stream_id: ::std::option::Option<::protobuf::Chars>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeletePersistentSubscription {
    fn default() -> &'a DeletePersistentSubscription {
        <DeletePersistentSubscription as ::protobuf::Message>::default_instance()
    }
}

impl DeletePersistentSubscription {
    pub fn new() -> DeletePersistentSubscription {
        ::std::default::Default::default()
    }

    // required string subscription_group_name = 1;


    pub fn get_subscription_group_name(&self) -> &str {
        match self.subscription_group_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_subscription_group_name(&mut self) {
        self.subscription_group_name = ::std::option::Option::None;
    }

    pub fn has_subscription_group_name(&self) -> bool {
        self.subscription_group_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscription_group_name(&mut self, v: ::protobuf::Chars) {
        self.subscription_group_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription_group_name(&mut self) -> &mut ::protobuf::Chars {
        if self.subscription_group_name.is_none() {
            self.subscription_group_name = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.subscription_group_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_subscription_group_name(&mut self) -> ::protobuf::Chars {
        self.subscription_group_name.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // required string event_stream_id = 2;


    pub fn get_event_stream_id(&self) -> &str {
        match self.event_stream_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_event_stream_id(&mut self) {
        self.event_stream_id = ::std::option::Option::None;
    }

    pub fn has_event_stream_id(&self) -> bool {
        self.event_stream_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stream_id(&mut self, v: ::protobuf::Chars) {
        self.event_stream_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_stream_id(&mut self) -> &mut ::protobuf::Chars {
        if self.event_stream_id.is_none() {
            self.event_stream_id = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.event_stream_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_stream_id(&mut self) -> ::protobuf::Chars {
        self.event_stream_id.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for DeletePersistentSubscription {
    fn is_initialized(&self) -> bool {
        if self.subscription_group_name.is_none() {
            return false;
        }
        if self.event_stream_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.subscription_group_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.event_stream_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.subscription_group_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.event_stream_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.subscription_group_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(ref v) = self.event_stream_id.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeletePersistentSubscription {
        DeletePersistentSubscription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "subscription_group_name",
                    |m: &DeletePersistentSubscription| { &m.subscription_group_name },
                    |m: &mut DeletePersistentSubscription| { &mut m.subscription_group_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "event_stream_id",
                    |m: &DeletePersistentSubscription| { &m.event_stream_id },
                    |m: &mut DeletePersistentSubscription| { &mut m.event_stream_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeletePersistentSubscription>(
                    "DeletePersistentSubscription",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeletePersistentSubscription {
        static mut instance: ::protobuf::lazy::Lazy<DeletePersistentSubscription> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeletePersistentSubscription,
        };
        unsafe {
            instance.get(DeletePersistentSubscription::new)
        }
    }
}

impl ::protobuf::Clear for DeletePersistentSubscription {
    fn clear(&mut self) {
        self.subscription_group_name = ::std::option::Option::None;
        self.event_stream_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeletePersistentSubscription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeletePersistentSubscription {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdatePersistentSubscription {
    // message fields
    subscription_group_name: ::std::option::Option<::protobuf::Chars>,
    event_stream_id: ::std::option::Option<::protobuf::Chars>,
    resolve_link_tos: ::std::option::Option<bool>,
    start_from: ::std::option::Option<i64>,
    message_timeout_milliseconds: ::std::option::Option<i32>,
    record_statistics: ::std::option::Option<bool>,
    live_buffer_size: ::std::option::Option<i32>,
    read_batch_size: ::std::option::Option<i32>,
    buffer_size: ::std::option::Option<i32>,
    max_retry_count: ::std::option::Option<i32>,
    prefer_round_robin: ::std::option::Option<bool>,
    checkpoint_after_time: ::std::option::Option<i32>,
    checkpoint_max_count: ::std::option::Option<i32>,
    checkpoint_min_count: ::std::option::Option<i32>,
    subscriber_max_count: ::std::option::Option<i32>,
    named_consumer_strategy: ::std::option::Option<::protobuf::Chars>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdatePersistentSubscription {
    fn default() -> &'a UpdatePersistentSubscription {
        <UpdatePersistentSubscription as ::protobuf::Message>::default_instance()
    }
}

impl UpdatePersistentSubscription {
    pub fn new() -> UpdatePersistentSubscription {
        ::std::default::Default::default()
    }

    // required string subscription_group_name = 1;


    pub fn get_subscription_group_name(&self) -> &str {
        match self.subscription_group_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_subscription_group_name(&mut self) {
        self.subscription_group_name = ::std::option::Option::None;
    }

    pub fn has_subscription_group_name(&self) -> bool {
        self.subscription_group_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscription_group_name(&mut self, v: ::protobuf::Chars) {
        self.subscription_group_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription_group_name(&mut self) -> &mut ::protobuf::Chars {
        if self.subscription_group_name.is_none() {
            self.subscription_group_name = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.subscription_group_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_subscription_group_name(&mut self) -> ::protobuf::Chars {
        self.subscription_group_name.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // required string event_stream_id = 2;


    pub fn get_event_stream_id(&self) -> &str {
        match self.event_stream_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_event_stream_id(&mut self) {
        self.event_stream_id = ::std::option::Option::None;
    }

    pub fn has_event_stream_id(&self) -> bool {
        self.event_stream_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stream_id(&mut self, v: ::protobuf::Chars) {
        self.event_stream_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_stream_id(&mut self) -> &mut ::protobuf::Chars {
        if self.event_stream_id.is_none() {
            self.event_stream_id = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.event_stream_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_stream_id(&mut self) -> ::protobuf::Chars {
        self.event_stream_id.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // required bool resolve_link_tos = 3;


    pub fn get_resolve_link_tos(&self) -> bool {
        self.resolve_link_tos.unwrap_or(false)
    }
    pub fn clear_resolve_link_tos(&mut self) {
        self.resolve_link_tos = ::std::option::Option::None;
    }

    pub fn has_resolve_link_tos(&self) -> bool {
        self.resolve_link_tos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resolve_link_tos(&mut self, v: bool) {
        self.resolve_link_tos = ::std::option::Option::Some(v);
    }

    // required int64 start_from = 4;


    pub fn get_start_from(&self) -> i64 {
        self.start_from.unwrap_or(0)
    }
    pub fn clear_start_from(&mut self) {
        self.start_from = ::std::option::Option::None;
    }

    pub fn has_start_from(&self) -> bool {
        self.start_from.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_from(&mut self, v: i64) {
        self.start_from = ::std::option::Option::Some(v);
    }

    // required int32 message_timeout_milliseconds = 5;


    pub fn get_message_timeout_milliseconds(&self) -> i32 {
        self.message_timeout_milliseconds.unwrap_or(0)
    }
    pub fn clear_message_timeout_milliseconds(&mut self) {
        self.message_timeout_milliseconds = ::std::option::Option::None;
    }

    pub fn has_message_timeout_milliseconds(&self) -> bool {
        self.message_timeout_milliseconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_timeout_milliseconds(&mut self, v: i32) {
        self.message_timeout_milliseconds = ::std::option::Option::Some(v);
    }

    // required bool record_statistics = 6;


    pub fn get_record_statistics(&self) -> bool {
        self.record_statistics.unwrap_or(false)
    }
    pub fn clear_record_statistics(&mut self) {
        self.record_statistics = ::std::option::Option::None;
    }

    pub fn has_record_statistics(&self) -> bool {
        self.record_statistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_record_statistics(&mut self, v: bool) {
        self.record_statistics = ::std::option::Option::Some(v);
    }

    // required int32 live_buffer_size = 7;


    pub fn get_live_buffer_size(&self) -> i32 {
        self.live_buffer_size.unwrap_or(0)
    }
    pub fn clear_live_buffer_size(&mut self) {
        self.live_buffer_size = ::std::option::Option::None;
    }

    pub fn has_live_buffer_size(&self) -> bool {
        self.live_buffer_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_live_buffer_size(&mut self, v: i32) {
        self.live_buffer_size = ::std::option::Option::Some(v);
    }

    // required int32 read_batch_size = 8;


    pub fn get_read_batch_size(&self) -> i32 {
        self.read_batch_size.unwrap_or(0)
    }
    pub fn clear_read_batch_size(&mut self) {
        self.read_batch_size = ::std::option::Option::None;
    }

    pub fn has_read_batch_size(&self) -> bool {
        self.read_batch_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read_batch_size(&mut self, v: i32) {
        self.read_batch_size = ::std::option::Option::Some(v);
    }

    // required int32 buffer_size = 9;


    pub fn get_buffer_size(&self) -> i32 {
        self.buffer_size.unwrap_or(0)
    }
    pub fn clear_buffer_size(&mut self) {
        self.buffer_size = ::std::option::Option::None;
    }

    pub fn has_buffer_size(&self) -> bool {
        self.buffer_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buffer_size(&mut self, v: i32) {
        self.buffer_size = ::std::option::Option::Some(v);
    }

    // required int32 max_retry_count = 10;


    pub fn get_max_retry_count(&self) -> i32 {
        self.max_retry_count.unwrap_or(0)
    }
    pub fn clear_max_retry_count(&mut self) {
        self.max_retry_count = ::std::option::Option::None;
    }

    pub fn has_max_retry_count(&self) -> bool {
        self.max_retry_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_retry_count(&mut self, v: i32) {
        self.max_retry_count = ::std::option::Option::Some(v);
    }

    // required bool prefer_round_robin = 11;


    pub fn get_prefer_round_robin(&self) -> bool {
        self.prefer_round_robin.unwrap_or(false)
    }
    pub fn clear_prefer_round_robin(&mut self) {
        self.prefer_round_robin = ::std::option::Option::None;
    }

    pub fn has_prefer_round_robin(&self) -> bool {
        self.prefer_round_robin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prefer_round_robin(&mut self, v: bool) {
        self.prefer_round_robin = ::std::option::Option::Some(v);
    }

    // required int32 checkpoint_after_time = 12;


    pub fn get_checkpoint_after_time(&self) -> i32 {
        self.checkpoint_after_time.unwrap_or(0)
    }
    pub fn clear_checkpoint_after_time(&mut self) {
        self.checkpoint_after_time = ::std::option::Option::None;
    }

    pub fn has_checkpoint_after_time(&self) -> bool {
        self.checkpoint_after_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checkpoint_after_time(&mut self, v: i32) {
        self.checkpoint_after_time = ::std::option::Option::Some(v);
    }

    // required int32 checkpoint_max_count = 13;


    pub fn get_checkpoint_max_count(&self) -> i32 {
        self.checkpoint_max_count.unwrap_or(0)
    }
    pub fn clear_checkpoint_max_count(&mut self) {
        self.checkpoint_max_count = ::std::option::Option::None;
    }

    pub fn has_checkpoint_max_count(&self) -> bool {
        self.checkpoint_max_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checkpoint_max_count(&mut self, v: i32) {
        self.checkpoint_max_count = ::std::option::Option::Some(v);
    }

    // required int32 checkpoint_min_count = 14;


    pub fn get_checkpoint_min_count(&self) -> i32 {
        self.checkpoint_min_count.unwrap_or(0)
    }
    pub fn clear_checkpoint_min_count(&mut self) {
        self.checkpoint_min_count = ::std::option::Option::None;
    }

    pub fn has_checkpoint_min_count(&self) -> bool {
        self.checkpoint_min_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checkpoint_min_count(&mut self, v: i32) {
        self.checkpoint_min_count = ::std::option::Option::Some(v);
    }

    // required int32 subscriber_max_count = 15;


    pub fn get_subscriber_max_count(&self) -> i32 {
        self.subscriber_max_count.unwrap_or(0)
    }
    pub fn clear_subscriber_max_count(&mut self) {
        self.subscriber_max_count = ::std::option::Option::None;
    }

    pub fn has_subscriber_max_count(&self) -> bool {
        self.subscriber_max_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscriber_max_count(&mut self, v: i32) {
        self.subscriber_max_count = ::std::option::Option::Some(v);
    }

    // optional string named_consumer_strategy = 16;


    pub fn get_named_consumer_strategy(&self) -> &str {
        match self.named_consumer_strategy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_named_consumer_strategy(&mut self) {
        self.named_consumer_strategy = ::std::option::Option::None;
    }

    pub fn has_named_consumer_strategy(&self) -> bool {
        self.named_consumer_strategy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_named_consumer_strategy(&mut self, v: ::protobuf::Chars) {
        self.named_consumer_strategy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_named_consumer_strategy(&mut self) -> &mut ::protobuf::Chars {
        if self.named_consumer_strategy.is_none() {
            self.named_consumer_strategy = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.named_consumer_strategy.as_mut().unwrap()
    }

    // Take field
    pub fn take_named_consumer_strategy(&mut self) -> ::protobuf::Chars {
        self.named_consumer_strategy.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for UpdatePersistentSubscription {
    fn is_initialized(&self) -> bool {
        if self.subscription_group_name.is_none() {
            return false;
        }
        if self.event_stream_id.is_none() {
            return false;
        }
        if self.resolve_link_tos.is_none() {
            return false;
        }
        if self.start_from.is_none() {
            return false;
        }
        if self.message_timeout_milliseconds.is_none() {
            return false;
        }
        if self.record_statistics.is_none() {
            return false;
        }
        if self.live_buffer_size.is_none() {
            return false;
        }
        if self.read_batch_size.is_none() {
            return false;
        }
        if self.buffer_size.is_none() {
            return false;
        }
        if self.max_retry_count.is_none() {
            return false;
        }
        if self.prefer_round_robin.is_none() {
            return false;
        }
        if self.checkpoint_after_time.is_none() {
            return false;
        }
        if self.checkpoint_max_count.is_none() {
            return false;
        }
        if self.checkpoint_min_count.is_none() {
            return false;
        }
        if self.subscriber_max_count.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.subscription_group_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.event_stream_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.resolve_link_tos = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.start_from = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.message_timeout_milliseconds = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.record_statistics = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.live_buffer_size = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.read_batch_size = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.buffer_size = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_retry_count = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prefer_round_robin = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.checkpoint_after_time = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.checkpoint_max_count = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.checkpoint_min_count = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.subscriber_max_count = ::std::option::Option::Some(tmp);
                },
                16 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.named_consumer_strategy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.subscription_group_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.event_stream_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.resolve_link_tos {
            my_size += 2;
        }
        if let Some(v) = self.start_from {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.message_timeout_milliseconds {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.record_statistics {
            my_size += 2;
        }
        if let Some(v) = self.live_buffer_size {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.read_batch_size {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.buffer_size {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_retry_count {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prefer_round_robin {
            my_size += 2;
        }
        if let Some(v) = self.checkpoint_after_time {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.checkpoint_max_count {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.checkpoint_min_count {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.subscriber_max_count {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.named_consumer_strategy.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.subscription_group_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(ref v) = self.event_stream_id.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.resolve_link_tos {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.start_from {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.message_timeout_milliseconds {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.record_statistics {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.live_buffer_size {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.read_batch_size {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.buffer_size {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.max_retry_count {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.prefer_round_robin {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.checkpoint_after_time {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.checkpoint_max_count {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.checkpoint_min_count {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.subscriber_max_count {
            os.write_int32(15, v)?;
        }
        if let Some(ref v) = self.named_consumer_strategy.as_ref() {
            os.write_string(16, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdatePersistentSubscription {
        UpdatePersistentSubscription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "subscription_group_name",
                    |m: &UpdatePersistentSubscription| { &m.subscription_group_name },
                    |m: &mut UpdatePersistentSubscription| { &mut m.subscription_group_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "event_stream_id",
                    |m: &UpdatePersistentSubscription| { &m.event_stream_id },
                    |m: &mut UpdatePersistentSubscription| { &mut m.event_stream_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "resolve_link_tos",
                    |m: &UpdatePersistentSubscription| { &m.resolve_link_tos },
                    |m: &mut UpdatePersistentSubscription| { &mut m.resolve_link_tos },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "start_from",
                    |m: &UpdatePersistentSubscription| { &m.start_from },
                    |m: &mut UpdatePersistentSubscription| { &mut m.start_from },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "message_timeout_milliseconds",
                    |m: &UpdatePersistentSubscription| { &m.message_timeout_milliseconds },
                    |m: &mut UpdatePersistentSubscription| { &mut m.message_timeout_milliseconds },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "record_statistics",
                    |m: &UpdatePersistentSubscription| { &m.record_statistics },
                    |m: &mut UpdatePersistentSubscription| { &mut m.record_statistics },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "live_buffer_size",
                    |m: &UpdatePersistentSubscription| { &m.live_buffer_size },
                    |m: &mut UpdatePersistentSubscription| { &mut m.live_buffer_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "read_batch_size",
                    |m: &UpdatePersistentSubscription| { &m.read_batch_size },
                    |m: &mut UpdatePersistentSubscription| { &mut m.read_batch_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "buffer_size",
                    |m: &UpdatePersistentSubscription| { &m.buffer_size },
                    |m: &mut UpdatePersistentSubscription| { &mut m.buffer_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "max_retry_count",
                    |m: &UpdatePersistentSubscription| { &m.max_retry_count },
                    |m: &mut UpdatePersistentSubscription| { &mut m.max_retry_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "prefer_round_robin",
                    |m: &UpdatePersistentSubscription| { &m.prefer_round_robin },
                    |m: &mut UpdatePersistentSubscription| { &mut m.prefer_round_robin },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "checkpoint_after_time",
                    |m: &UpdatePersistentSubscription| { &m.checkpoint_after_time },
                    |m: &mut UpdatePersistentSubscription| { &mut m.checkpoint_after_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "checkpoint_max_count",
                    |m: &UpdatePersistentSubscription| { &m.checkpoint_max_count },
                    |m: &mut UpdatePersistentSubscription| { &mut m.checkpoint_max_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "checkpoint_min_count",
                    |m: &UpdatePersistentSubscription| { &m.checkpoint_min_count },
                    |m: &mut UpdatePersistentSubscription| { &mut m.checkpoint_min_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "subscriber_max_count",
                    |m: &UpdatePersistentSubscription| { &m.subscriber_max_count },
                    |m: &mut UpdatePersistentSubscription| { &mut m.subscriber_max_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "named_consumer_strategy",
                    |m: &UpdatePersistentSubscription| { &m.named_consumer_strategy },
                    |m: &mut UpdatePersistentSubscription| { &mut m.named_consumer_strategy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdatePersistentSubscription>(
                    "UpdatePersistentSubscription",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdatePersistentSubscription {
        static mut instance: ::protobuf::lazy::Lazy<UpdatePersistentSubscription> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdatePersistentSubscription,
        };
        unsafe {
            instance.get(UpdatePersistentSubscription::new)
        }
    }
}

impl ::protobuf::Clear for UpdatePersistentSubscription {
    fn clear(&mut self) {
        self.subscription_group_name = ::std::option::Option::None;
        self.event_stream_id = ::std::option::Option::None;
        self.resolve_link_tos = ::std::option::Option::None;
        self.start_from = ::std::option::Option::None;
        self.message_timeout_milliseconds = ::std::option::Option::None;
        self.record_statistics = ::std::option::Option::None;
        self.live_buffer_size = ::std::option::Option::None;
        self.read_batch_size = ::std::option::Option::None;
        self.buffer_size = ::std::option::Option::None;
        self.max_retry_count = ::std::option::Option::None;
        self.prefer_round_robin = ::std::option::Option::None;
        self.checkpoint_after_time = ::std::option::Option::None;
        self.checkpoint_max_count = ::std::option::Option::None;
        self.checkpoint_min_count = ::std::option::Option::None;
        self.subscriber_max_count = ::std::option::Option::None;
        self.named_consumer_strategy = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdatePersistentSubscription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdatePersistentSubscription {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdatePersistentSubscriptionCompleted {
    // message fields
    result: ::std::option::Option<UpdatePersistentSubscriptionCompleted_UpdatePersistentSubscriptionResult>,
    reason: ::std::option::Option<::protobuf::Chars>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdatePersistentSubscriptionCompleted {
    fn default() -> &'a UpdatePersistentSubscriptionCompleted {
        <UpdatePersistentSubscriptionCompleted as ::protobuf::Message>::default_instance()
    }
}

impl UpdatePersistentSubscriptionCompleted {
    pub fn new() -> UpdatePersistentSubscriptionCompleted {
        ::std::default::Default::default()
    }

    // required .EventStore.Client.Messages.UpdatePersistentSubscriptionCompleted.UpdatePersistentSubscriptionResult result = 1;


    pub fn get_result(&self) -> UpdatePersistentSubscriptionCompleted_UpdatePersistentSubscriptionResult {
        self.result.unwrap_or(UpdatePersistentSubscriptionCompleted_UpdatePersistentSubscriptionResult::Success)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: UpdatePersistentSubscriptionCompleted_UpdatePersistentSubscriptionResult) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional string reason = 2;


    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::protobuf::Chars) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::protobuf::Chars {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::protobuf::Chars {
        self.reason.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for UpdatePersistentSubscriptionCompleted {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.reason)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdatePersistentSubscriptionCompleted {
        UpdatePersistentSubscriptionCompleted::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<UpdatePersistentSubscriptionCompleted_UpdatePersistentSubscriptionResult>>(
                    "result",
                    |m: &UpdatePersistentSubscriptionCompleted| { &m.result },
                    |m: &mut UpdatePersistentSubscriptionCompleted| { &mut m.result },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "reason",
                    |m: &UpdatePersistentSubscriptionCompleted| { &m.reason },
                    |m: &mut UpdatePersistentSubscriptionCompleted| { &mut m.reason },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdatePersistentSubscriptionCompleted>(
                    "UpdatePersistentSubscriptionCompleted",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdatePersistentSubscriptionCompleted {
        static mut instance: ::protobuf::lazy::Lazy<UpdatePersistentSubscriptionCompleted> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdatePersistentSubscriptionCompleted,
        };
        unsafe {
            instance.get(UpdatePersistentSubscriptionCompleted::new)
        }
    }
}

impl ::protobuf::Clear for UpdatePersistentSubscriptionCompleted {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdatePersistentSubscriptionCompleted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdatePersistentSubscriptionCompleted {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum UpdatePersistentSubscriptionCompleted_UpdatePersistentSubscriptionResult {
    Success = 0,
    DoesNotExist = 1,
    Fail = 2,
    AccessDenied = 3,
}

impl ::protobuf::ProtobufEnum for UpdatePersistentSubscriptionCompleted_UpdatePersistentSubscriptionResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UpdatePersistentSubscriptionCompleted_UpdatePersistentSubscriptionResult> {
        match value {
            0 => ::std::option::Option::Some(UpdatePersistentSubscriptionCompleted_UpdatePersistentSubscriptionResult::Success),
            1 => ::std::option::Option::Some(UpdatePersistentSubscriptionCompleted_UpdatePersistentSubscriptionResult::DoesNotExist),
            2 => ::std::option::Option::Some(UpdatePersistentSubscriptionCompleted_UpdatePersistentSubscriptionResult::Fail),
            3 => ::std::option::Option::Some(UpdatePersistentSubscriptionCompleted_UpdatePersistentSubscriptionResult::AccessDenied),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [UpdatePersistentSubscriptionCompleted_UpdatePersistentSubscriptionResult] = &[
            UpdatePersistentSubscriptionCompleted_UpdatePersistentSubscriptionResult::Success,
            UpdatePersistentSubscriptionCompleted_UpdatePersistentSubscriptionResult::DoesNotExist,
            UpdatePersistentSubscriptionCompleted_UpdatePersistentSubscriptionResult::Fail,
            UpdatePersistentSubscriptionCompleted_UpdatePersistentSubscriptionResult::AccessDenied,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("UpdatePersistentSubscriptionCompleted_UpdatePersistentSubscriptionResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for UpdatePersistentSubscriptionCompleted_UpdatePersistentSubscriptionResult {
}

impl ::std::default::Default for UpdatePersistentSubscriptionCompleted_UpdatePersistentSubscriptionResult {
    fn default() -> Self {
        UpdatePersistentSubscriptionCompleted_UpdatePersistentSubscriptionResult::Success
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdatePersistentSubscriptionCompleted_UpdatePersistentSubscriptionResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreatePersistentSubscriptionCompleted {
    // message fields
    result: ::std::option::Option<CreatePersistentSubscriptionCompleted_CreatePersistentSubscriptionResult>,
    reason: ::std::option::Option<::protobuf::Chars>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreatePersistentSubscriptionCompleted {
    fn default() -> &'a CreatePersistentSubscriptionCompleted {
        <CreatePersistentSubscriptionCompleted as ::protobuf::Message>::default_instance()
    }
}

impl CreatePersistentSubscriptionCompleted {
    pub fn new() -> CreatePersistentSubscriptionCompleted {
        ::std::default::Default::default()
    }

    // required .EventStore.Client.Messages.CreatePersistentSubscriptionCompleted.CreatePersistentSubscriptionResult result = 1;


    pub fn get_result(&self) -> CreatePersistentSubscriptionCompleted_CreatePersistentSubscriptionResult {
        self.result.unwrap_or(CreatePersistentSubscriptionCompleted_CreatePersistentSubscriptionResult::Success)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CreatePersistentSubscriptionCompleted_CreatePersistentSubscriptionResult) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional string reason = 2;


    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::protobuf::Chars) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::protobuf::Chars {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::protobuf::Chars {
        self.reason.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for CreatePersistentSubscriptionCompleted {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.reason)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreatePersistentSubscriptionCompleted {
        CreatePersistentSubscriptionCompleted::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CreatePersistentSubscriptionCompleted_CreatePersistentSubscriptionResult>>(
                    "result",
                    |m: &CreatePersistentSubscriptionCompleted| { &m.result },
                    |m: &mut CreatePersistentSubscriptionCompleted| { &mut m.result },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "reason",
                    |m: &CreatePersistentSubscriptionCompleted| { &m.reason },
                    |m: &mut CreatePersistentSubscriptionCompleted| { &mut m.reason },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreatePersistentSubscriptionCompleted>(
                    "CreatePersistentSubscriptionCompleted",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreatePersistentSubscriptionCompleted {
        static mut instance: ::protobuf::lazy::Lazy<CreatePersistentSubscriptionCompleted> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreatePersistentSubscriptionCompleted,
        };
        unsafe {
            instance.get(CreatePersistentSubscriptionCompleted::new)
        }
    }
}

impl ::protobuf::Clear for CreatePersistentSubscriptionCompleted {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreatePersistentSubscriptionCompleted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreatePersistentSubscriptionCompleted {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CreatePersistentSubscriptionCompleted_CreatePersistentSubscriptionResult {
    Success = 0,
    AlreadyExists = 1,
    Fail = 2,
    AccessDenied = 3,
}

impl ::protobuf::ProtobufEnum for CreatePersistentSubscriptionCompleted_CreatePersistentSubscriptionResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CreatePersistentSubscriptionCompleted_CreatePersistentSubscriptionResult> {
        match value {
            0 => ::std::option::Option::Some(CreatePersistentSubscriptionCompleted_CreatePersistentSubscriptionResult::Success),
            1 => ::std::option::Option::Some(CreatePersistentSubscriptionCompleted_CreatePersistentSubscriptionResult::AlreadyExists),
            2 => ::std::option::Option::Some(CreatePersistentSubscriptionCompleted_CreatePersistentSubscriptionResult::Fail),
            3 => ::std::option::Option::Some(CreatePersistentSubscriptionCompleted_CreatePersistentSubscriptionResult::AccessDenied),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CreatePersistentSubscriptionCompleted_CreatePersistentSubscriptionResult] = &[
            CreatePersistentSubscriptionCompleted_CreatePersistentSubscriptionResult::Success,
            CreatePersistentSubscriptionCompleted_CreatePersistentSubscriptionResult::AlreadyExists,
            CreatePersistentSubscriptionCompleted_CreatePersistentSubscriptionResult::Fail,
            CreatePersistentSubscriptionCompleted_CreatePersistentSubscriptionResult::AccessDenied,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CreatePersistentSubscriptionCompleted_CreatePersistentSubscriptionResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CreatePersistentSubscriptionCompleted_CreatePersistentSubscriptionResult {
}

impl ::std::default::Default for CreatePersistentSubscriptionCompleted_CreatePersistentSubscriptionResult {
    fn default() -> Self {
        CreatePersistentSubscriptionCompleted_CreatePersistentSubscriptionResult::Success
    }
}

impl ::protobuf::reflect::ProtobufValue for CreatePersistentSubscriptionCompleted_CreatePersistentSubscriptionResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeletePersistentSubscriptionCompleted {
    // message fields
    result: ::std::option::Option<DeletePersistentSubscriptionCompleted_DeletePersistentSubscriptionResult>,
    reason: ::std::option::Option<::protobuf::Chars>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeletePersistentSubscriptionCompleted {
    fn default() -> &'a DeletePersistentSubscriptionCompleted {
        <DeletePersistentSubscriptionCompleted as ::protobuf::Message>::default_instance()
    }
}

impl DeletePersistentSubscriptionCompleted {
    pub fn new() -> DeletePersistentSubscriptionCompleted {
        ::std::default::Default::default()
    }

    // required .EventStore.Client.Messages.DeletePersistentSubscriptionCompleted.DeletePersistentSubscriptionResult result = 1;


    pub fn get_result(&self) -> DeletePersistentSubscriptionCompleted_DeletePersistentSubscriptionResult {
        self.result.unwrap_or(DeletePersistentSubscriptionCompleted_DeletePersistentSubscriptionResult::Success)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: DeletePersistentSubscriptionCompleted_DeletePersistentSubscriptionResult) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional string reason = 2;


    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::protobuf::Chars) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::protobuf::Chars {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::protobuf::Chars {
        self.reason.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for DeletePersistentSubscriptionCompleted {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.reason)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeletePersistentSubscriptionCompleted {
        DeletePersistentSubscriptionCompleted::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DeletePersistentSubscriptionCompleted_DeletePersistentSubscriptionResult>>(
                    "result",
                    |m: &DeletePersistentSubscriptionCompleted| { &m.result },
                    |m: &mut DeletePersistentSubscriptionCompleted| { &mut m.result },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "reason",
                    |m: &DeletePersistentSubscriptionCompleted| { &m.reason },
                    |m: &mut DeletePersistentSubscriptionCompleted| { &mut m.reason },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeletePersistentSubscriptionCompleted>(
                    "DeletePersistentSubscriptionCompleted",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeletePersistentSubscriptionCompleted {
        static mut instance: ::protobuf::lazy::Lazy<DeletePersistentSubscriptionCompleted> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeletePersistentSubscriptionCompleted,
        };
        unsafe {
            instance.get(DeletePersistentSubscriptionCompleted::new)
        }
    }
}

impl ::protobuf::Clear for DeletePersistentSubscriptionCompleted {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeletePersistentSubscriptionCompleted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeletePersistentSubscriptionCompleted {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DeletePersistentSubscriptionCompleted_DeletePersistentSubscriptionResult {
    Success = 0,
    DoesNotExist = 1,
    Fail = 2,
    AccessDenied = 3,
}

impl ::protobuf::ProtobufEnum for DeletePersistentSubscriptionCompleted_DeletePersistentSubscriptionResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DeletePersistentSubscriptionCompleted_DeletePersistentSubscriptionResult> {
        match value {
            0 => ::std::option::Option::Some(DeletePersistentSubscriptionCompleted_DeletePersistentSubscriptionResult::Success),
            1 => ::std::option::Option::Some(DeletePersistentSubscriptionCompleted_DeletePersistentSubscriptionResult::DoesNotExist),
            2 => ::std::option::Option::Some(DeletePersistentSubscriptionCompleted_DeletePersistentSubscriptionResult::Fail),
            3 => ::std::option::Option::Some(DeletePersistentSubscriptionCompleted_DeletePersistentSubscriptionResult::AccessDenied),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DeletePersistentSubscriptionCompleted_DeletePersistentSubscriptionResult] = &[
            DeletePersistentSubscriptionCompleted_DeletePersistentSubscriptionResult::Success,
            DeletePersistentSubscriptionCompleted_DeletePersistentSubscriptionResult::DoesNotExist,
            DeletePersistentSubscriptionCompleted_DeletePersistentSubscriptionResult::Fail,
            DeletePersistentSubscriptionCompleted_DeletePersistentSubscriptionResult::AccessDenied,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DeletePersistentSubscriptionCompleted_DeletePersistentSubscriptionResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DeletePersistentSubscriptionCompleted_DeletePersistentSubscriptionResult {
}

impl ::std::default::Default for DeletePersistentSubscriptionCompleted_DeletePersistentSubscriptionResult {
    fn default() -> Self {
        DeletePersistentSubscriptionCompleted_DeletePersistentSubscriptionResult::Success
    }
}

impl ::protobuf::reflect::ProtobufValue for DeletePersistentSubscriptionCompleted_DeletePersistentSubscriptionResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnectToPersistentSubscription {
    // message fields
    subscription_id: ::std::option::Option<::protobuf::Chars>,
    event_stream_id: ::std::option::Option<::protobuf::Chars>,
    allowed_in_flight_messages: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnectToPersistentSubscription {
    fn default() -> &'a ConnectToPersistentSubscription {
        <ConnectToPersistentSubscription as ::protobuf::Message>::default_instance()
    }
}

impl ConnectToPersistentSubscription {
    pub fn new() -> ConnectToPersistentSubscription {
        ::std::default::Default::default()
    }

    // required string subscription_id = 1;


    pub fn get_subscription_id(&self) -> &str {
        match self.subscription_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_subscription_id(&mut self) {
        self.subscription_id = ::std::option::Option::None;
    }

    pub fn has_subscription_id(&self) -> bool {
        self.subscription_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscription_id(&mut self, v: ::protobuf::Chars) {
        self.subscription_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription_id(&mut self) -> &mut ::protobuf::Chars {
        if self.subscription_id.is_none() {
            self.subscription_id = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.subscription_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_subscription_id(&mut self) -> ::protobuf::Chars {
        self.subscription_id.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // required string event_stream_id = 2;


    pub fn get_event_stream_id(&self) -> &str {
        match self.event_stream_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_event_stream_id(&mut self) {
        self.event_stream_id = ::std::option::Option::None;
    }

    pub fn has_event_stream_id(&self) -> bool {
        self.event_stream_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stream_id(&mut self, v: ::protobuf::Chars) {
        self.event_stream_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_stream_id(&mut self) -> &mut ::protobuf::Chars {
        if self.event_stream_id.is_none() {
            self.event_stream_id = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.event_stream_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_stream_id(&mut self) -> ::protobuf::Chars {
        self.event_stream_id.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // required int32 allowed_in_flight_messages = 3;


    pub fn get_allowed_in_flight_messages(&self) -> i32 {
        self.allowed_in_flight_messages.unwrap_or(0)
    }
    pub fn clear_allowed_in_flight_messages(&mut self) {
        self.allowed_in_flight_messages = ::std::option::Option::None;
    }

    pub fn has_allowed_in_flight_messages(&self) -> bool {
        self.allowed_in_flight_messages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allowed_in_flight_messages(&mut self, v: i32) {
        self.allowed_in_flight_messages = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ConnectToPersistentSubscription {
    fn is_initialized(&self) -> bool {
        if self.subscription_id.is_none() {
            return false;
        }
        if self.event_stream_id.is_none() {
            return false;
        }
        if self.allowed_in_flight_messages.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.subscription_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.event_stream_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.allowed_in_flight_messages = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.subscription_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.event_stream_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.allowed_in_flight_messages {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.subscription_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(ref v) = self.event_stream_id.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.allowed_in_flight_messages {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnectToPersistentSubscription {
        ConnectToPersistentSubscription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "subscription_id",
                    |m: &ConnectToPersistentSubscription| { &m.subscription_id },
                    |m: &mut ConnectToPersistentSubscription| { &mut m.subscription_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "event_stream_id",
                    |m: &ConnectToPersistentSubscription| { &m.event_stream_id },
                    |m: &mut ConnectToPersistentSubscription| { &mut m.event_stream_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "allowed_in_flight_messages",
                    |m: &ConnectToPersistentSubscription| { &m.allowed_in_flight_messages },
                    |m: &mut ConnectToPersistentSubscription| { &mut m.allowed_in_flight_messages },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConnectToPersistentSubscription>(
                    "ConnectToPersistentSubscription",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConnectToPersistentSubscription {
        static mut instance: ::protobuf::lazy::Lazy<ConnectToPersistentSubscription> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConnectToPersistentSubscription,
        };
        unsafe {
            instance.get(ConnectToPersistentSubscription::new)
        }
    }
}

impl ::protobuf::Clear for ConnectToPersistentSubscription {
    fn clear(&mut self) {
        self.subscription_id = ::std::option::Option::None;
        self.event_stream_id = ::std::option::Option::None;
        self.allowed_in_flight_messages = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnectToPersistentSubscription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectToPersistentSubscription {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistentSubscriptionAckEvents {
    // message fields
    subscription_id: ::std::option::Option<::protobuf::Chars>,
    processed_event_ids: ::std::vec::Vec<::bytes::Bytes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistentSubscriptionAckEvents {
    fn default() -> &'a PersistentSubscriptionAckEvents {
        <PersistentSubscriptionAckEvents as ::protobuf::Message>::default_instance()
    }
}

impl PersistentSubscriptionAckEvents {
    pub fn new() -> PersistentSubscriptionAckEvents {
        ::std::default::Default::default()
    }

    // required string subscription_id = 1;


    pub fn get_subscription_id(&self) -> &str {
        match self.subscription_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_subscription_id(&mut self) {
        self.subscription_id = ::std::option::Option::None;
    }

    pub fn has_subscription_id(&self) -> bool {
        self.subscription_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscription_id(&mut self, v: ::protobuf::Chars) {
        self.subscription_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription_id(&mut self) -> &mut ::protobuf::Chars {
        if self.subscription_id.is_none() {
            self.subscription_id = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.subscription_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_subscription_id(&mut self) -> ::protobuf::Chars {
        self.subscription_id.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // repeated bytes processed_event_ids = 2;


    pub fn get_processed_event_ids(&self) -> &[::bytes::Bytes] {
        &self.processed_event_ids
    }
    pub fn clear_processed_event_ids(&mut self) {
        self.processed_event_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_processed_event_ids(&mut self, v: ::std::vec::Vec<::bytes::Bytes>) {
        self.processed_event_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_processed_event_ids(&mut self) -> &mut ::std::vec::Vec<::bytes::Bytes> {
        &mut self.processed_event_ids
    }

    // Take field
    pub fn take_processed_event_ids(&mut self) -> ::std::vec::Vec<::bytes::Bytes> {
        ::std::mem::replace(&mut self.processed_event_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PersistentSubscriptionAckEvents {
    fn is_initialized(&self) -> bool {
        if self.subscription_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.subscription_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_carllerche_bytes_into(wire_type, is, &mut self.processed_event_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.subscription_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.processed_event_ids {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.subscription_id.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.processed_event_ids {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistentSubscriptionAckEvents {
        PersistentSubscriptionAckEvents::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "subscription_id",
                    |m: &PersistentSubscriptionAckEvents| { &m.subscription_id },
                    |m: &mut PersistentSubscriptionAckEvents| { &mut m.subscription_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "processed_event_ids",
                    |m: &PersistentSubscriptionAckEvents| { &m.processed_event_ids },
                    |m: &mut PersistentSubscriptionAckEvents| { &mut m.processed_event_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PersistentSubscriptionAckEvents>(
                    "PersistentSubscriptionAckEvents",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PersistentSubscriptionAckEvents {
        static mut instance: ::protobuf::lazy::Lazy<PersistentSubscriptionAckEvents> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PersistentSubscriptionAckEvents,
        };
        unsafe {
            instance.get(PersistentSubscriptionAckEvents::new)
        }
    }
}

impl ::protobuf::Clear for PersistentSubscriptionAckEvents {
    fn clear(&mut self) {
        self.subscription_id = ::std::option::Option::None;
        self.processed_event_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistentSubscriptionAckEvents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentSubscriptionAckEvents {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistentSubscriptionNakEvents {
    // message fields
    subscription_id: ::std::option::Option<::protobuf::Chars>,
    processed_event_ids: ::std::vec::Vec<::bytes::Bytes>,
    message: ::std::option::Option<::protobuf::Chars>,
    action: ::std::option::Option<PersistentSubscriptionNakEvents_NakAction>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistentSubscriptionNakEvents {
    fn default() -> &'a PersistentSubscriptionNakEvents {
        <PersistentSubscriptionNakEvents as ::protobuf::Message>::default_instance()
    }
}

impl PersistentSubscriptionNakEvents {
    pub fn new() -> PersistentSubscriptionNakEvents {
        ::std::default::Default::default()
    }

    // required string subscription_id = 1;


    pub fn get_subscription_id(&self) -> &str {
        match self.subscription_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_subscription_id(&mut self) {
        self.subscription_id = ::std::option::Option::None;
    }

    pub fn has_subscription_id(&self) -> bool {
        self.subscription_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscription_id(&mut self, v: ::protobuf::Chars) {
        self.subscription_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription_id(&mut self) -> &mut ::protobuf::Chars {
        if self.subscription_id.is_none() {
            self.subscription_id = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.subscription_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_subscription_id(&mut self) -> ::protobuf::Chars {
        self.subscription_id.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // repeated bytes processed_event_ids = 2;


    pub fn get_processed_event_ids(&self) -> &[::bytes::Bytes] {
        &self.processed_event_ids
    }
    pub fn clear_processed_event_ids(&mut self) {
        self.processed_event_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_processed_event_ids(&mut self, v: ::std::vec::Vec<::bytes::Bytes>) {
        self.processed_event_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_processed_event_ids(&mut self) -> &mut ::std::vec::Vec<::bytes::Bytes> {
        &mut self.processed_event_ids
    }

    // Take field
    pub fn take_processed_event_ids(&mut self) -> ::std::vec::Vec<::bytes::Bytes> {
        ::std::mem::replace(&mut self.processed_event_ids, ::std::vec::Vec::new())
    }

    // optional string message = 3;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        self.message.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // required .EventStore.Client.Messages.PersistentSubscriptionNakEvents.NakAction action = 4;


    pub fn get_action(&self) -> PersistentSubscriptionNakEvents_NakAction {
        self.action.unwrap_or(PersistentSubscriptionNakEvents_NakAction::Unknown)
    }
    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: PersistentSubscriptionNakEvents_NakAction) {
        self.action = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PersistentSubscriptionNakEvents {
    fn is_initialized(&self) -> bool {
        if self.subscription_id.is_none() {
            return false;
        }
        if self.action.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.subscription_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_carllerche_bytes_into(wire_type, is, &mut self.processed_event_ids)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.subscription_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.processed_event_ids {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.subscription_id.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.processed_event_ids {
            os.write_bytes(2, &v)?;
        };
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.action {
            os.write_enum(4, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistentSubscriptionNakEvents {
        PersistentSubscriptionNakEvents::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "subscription_id",
                    |m: &PersistentSubscriptionNakEvents| { &m.subscription_id },
                    |m: &mut PersistentSubscriptionNakEvents| { &mut m.subscription_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "processed_event_ids",
                    |m: &PersistentSubscriptionNakEvents| { &m.processed_event_ids },
                    |m: &mut PersistentSubscriptionNakEvents| { &mut m.processed_event_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &PersistentSubscriptionNakEvents| { &m.message },
                    |m: &mut PersistentSubscriptionNakEvents| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PersistentSubscriptionNakEvents_NakAction>>(
                    "action",
                    |m: &PersistentSubscriptionNakEvents| { &m.action },
                    |m: &mut PersistentSubscriptionNakEvents| { &mut m.action },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PersistentSubscriptionNakEvents>(
                    "PersistentSubscriptionNakEvents",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PersistentSubscriptionNakEvents {
        static mut instance: ::protobuf::lazy::Lazy<PersistentSubscriptionNakEvents> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PersistentSubscriptionNakEvents,
        };
        unsafe {
            instance.get(PersistentSubscriptionNakEvents::new)
        }
    }
}

impl ::protobuf::Clear for PersistentSubscriptionNakEvents {
    fn clear(&mut self) {
        self.subscription_id = ::std::option::Option::None;
        self.processed_event_ids.clear();
        self.message = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistentSubscriptionNakEvents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentSubscriptionNakEvents {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PersistentSubscriptionNakEvents_NakAction {
    Unknown = 0,
    Park = 1,
    Retry = 2,
    Skip = 3,
    Stop = 4,
}

impl ::protobuf::ProtobufEnum for PersistentSubscriptionNakEvents_NakAction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PersistentSubscriptionNakEvents_NakAction> {
        match value {
            0 => ::std::option::Option::Some(PersistentSubscriptionNakEvents_NakAction::Unknown),
            1 => ::std::option::Option::Some(PersistentSubscriptionNakEvents_NakAction::Park),
            2 => ::std::option::Option::Some(PersistentSubscriptionNakEvents_NakAction::Retry),
            3 => ::std::option::Option::Some(PersistentSubscriptionNakEvents_NakAction::Skip),
            4 => ::std::option::Option::Some(PersistentSubscriptionNakEvents_NakAction::Stop),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PersistentSubscriptionNakEvents_NakAction] = &[
            PersistentSubscriptionNakEvents_NakAction::Unknown,
            PersistentSubscriptionNakEvents_NakAction::Park,
            PersistentSubscriptionNakEvents_NakAction::Retry,
            PersistentSubscriptionNakEvents_NakAction::Skip,
            PersistentSubscriptionNakEvents_NakAction::Stop,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PersistentSubscriptionNakEvents_NakAction", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PersistentSubscriptionNakEvents_NakAction {
}

impl ::std::default::Default for PersistentSubscriptionNakEvents_NakAction {
    fn default() -> Self {
        PersistentSubscriptionNakEvents_NakAction::Unknown
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentSubscriptionNakEvents_NakAction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistentSubscriptionConfirmation {
    // message fields
    last_commit_position: ::std::option::Option<i64>,
    subscription_id: ::std::option::Option<::protobuf::Chars>,
    last_event_number: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistentSubscriptionConfirmation {
    fn default() -> &'a PersistentSubscriptionConfirmation {
        <PersistentSubscriptionConfirmation as ::protobuf::Message>::default_instance()
    }
}

impl PersistentSubscriptionConfirmation {
    pub fn new() -> PersistentSubscriptionConfirmation {
        ::std::default::Default::default()
    }

    // required int64 last_commit_position = 1;


    pub fn get_last_commit_position(&self) -> i64 {
        self.last_commit_position.unwrap_or(0)
    }
    pub fn clear_last_commit_position(&mut self) {
        self.last_commit_position = ::std::option::Option::None;
    }

    pub fn has_last_commit_position(&self) -> bool {
        self.last_commit_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_commit_position(&mut self, v: i64) {
        self.last_commit_position = ::std::option::Option::Some(v);
    }

    // required string subscription_id = 2;


    pub fn get_subscription_id(&self) -> &str {
        match self.subscription_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_subscription_id(&mut self) {
        self.subscription_id = ::std::option::Option::None;
    }

    pub fn has_subscription_id(&self) -> bool {
        self.subscription_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscription_id(&mut self, v: ::protobuf::Chars) {
        self.subscription_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription_id(&mut self) -> &mut ::protobuf::Chars {
        if self.subscription_id.is_none() {
            self.subscription_id = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.subscription_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_subscription_id(&mut self) -> ::protobuf::Chars {
        self.subscription_id.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional int64 last_event_number = 3;


    pub fn get_last_event_number(&self) -> i64 {
        self.last_event_number.unwrap_or(0)
    }
    pub fn clear_last_event_number(&mut self) {
        self.last_event_number = ::std::option::Option::None;
    }

    pub fn has_last_event_number(&self) -> bool {
        self.last_event_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_event_number(&mut self, v: i64) {
        self.last_event_number = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PersistentSubscriptionConfirmation {
    fn is_initialized(&self) -> bool {
        if self.last_commit_position.is_none() {
            return false;
        }
        if self.subscription_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.last_commit_position = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.subscription_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.last_event_number = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.last_commit_position {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.subscription_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.last_event_number {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.last_commit_position {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.subscription_id.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.last_event_number {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistentSubscriptionConfirmation {
        PersistentSubscriptionConfirmation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "last_commit_position",
                    |m: &PersistentSubscriptionConfirmation| { &m.last_commit_position },
                    |m: &mut PersistentSubscriptionConfirmation| { &mut m.last_commit_position },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "subscription_id",
                    |m: &PersistentSubscriptionConfirmation| { &m.subscription_id },
                    |m: &mut PersistentSubscriptionConfirmation| { &mut m.subscription_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "last_event_number",
                    |m: &PersistentSubscriptionConfirmation| { &m.last_event_number },
                    |m: &mut PersistentSubscriptionConfirmation| { &mut m.last_event_number },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PersistentSubscriptionConfirmation>(
                    "PersistentSubscriptionConfirmation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PersistentSubscriptionConfirmation {
        static mut instance: ::protobuf::lazy::Lazy<PersistentSubscriptionConfirmation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PersistentSubscriptionConfirmation,
        };
        unsafe {
            instance.get(PersistentSubscriptionConfirmation::new)
        }
    }
}

impl ::protobuf::Clear for PersistentSubscriptionConfirmation {
    fn clear(&mut self) {
        self.last_commit_position = ::std::option::Option::None;
        self.subscription_id = ::std::option::Option::None;
        self.last_event_number = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistentSubscriptionConfirmation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentSubscriptionConfirmation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistentSubscriptionStreamEventAppeared {
    // message fields
    event: ::protobuf::SingularPtrField<ResolvedIndexedEvent>,
    retryCount: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistentSubscriptionStreamEventAppeared {
    fn default() -> &'a PersistentSubscriptionStreamEventAppeared {
        <PersistentSubscriptionStreamEventAppeared as ::protobuf::Message>::default_instance()
    }
}

impl PersistentSubscriptionStreamEventAppeared {
    pub fn new() -> PersistentSubscriptionStreamEventAppeared {
        ::std::default::Default::default()
    }

    // required .EventStore.Client.Messages.ResolvedIndexedEvent event = 1;


    pub fn get_event(&self) -> &ResolvedIndexedEvent {
        self.event.as_ref().unwrap_or_else(|| ResolvedIndexedEvent::default_instance())
    }
    pub fn clear_event(&mut self) {
        self.event.clear();
    }

    pub fn has_event(&self) -> bool {
        self.event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event(&mut self, v: ResolvedIndexedEvent) {
        self.event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event(&mut self) -> &mut ResolvedIndexedEvent {
        if self.event.is_none() {
            self.event.set_default();
        }
        self.event.as_mut().unwrap()
    }

    // Take field
    pub fn take_event(&mut self) -> ResolvedIndexedEvent {
        self.event.take().unwrap_or_else(|| ResolvedIndexedEvent::new())
    }

    // optional int32 retryCount = 2;


    pub fn get_retryCount(&self) -> i32 {
        self.retryCount.unwrap_or(0)
    }
    pub fn clear_retryCount(&mut self) {
        self.retryCount = ::std::option::Option::None;
    }

    pub fn has_retryCount(&self) -> bool {
        self.retryCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retryCount(&mut self, v: i32) {
        self.retryCount = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PersistentSubscriptionStreamEventAppeared {
    fn is_initialized(&self) -> bool {
        if self.event.is_none() {
            return false;
        }
        for v in &self.event {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.event)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.retryCount = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.retryCount {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.event.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.retryCount {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistentSubscriptionStreamEventAppeared {
        PersistentSubscriptionStreamEventAppeared::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResolvedIndexedEvent>>(
                    "event",
                    |m: &PersistentSubscriptionStreamEventAppeared| { &m.event },
                    |m: &mut PersistentSubscriptionStreamEventAppeared| { &mut m.event },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "retryCount",
                    |m: &PersistentSubscriptionStreamEventAppeared| { &m.retryCount },
                    |m: &mut PersistentSubscriptionStreamEventAppeared| { &mut m.retryCount },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PersistentSubscriptionStreamEventAppeared>(
                    "PersistentSubscriptionStreamEventAppeared",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PersistentSubscriptionStreamEventAppeared {
        static mut instance: ::protobuf::lazy::Lazy<PersistentSubscriptionStreamEventAppeared> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PersistentSubscriptionStreamEventAppeared,
        };
        unsafe {
            instance.get(PersistentSubscriptionStreamEventAppeared::new)
        }
    }
}

impl ::protobuf::Clear for PersistentSubscriptionStreamEventAppeared {
    fn clear(&mut self) {
        self.event.clear();
        self.retryCount = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistentSubscriptionStreamEventAppeared {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentSubscriptionStreamEventAppeared {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeToStream {
    // message fields
    event_stream_id: ::std::option::Option<::protobuf::Chars>,
    resolve_link_tos: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeToStream {
    fn default() -> &'a SubscribeToStream {
        <SubscribeToStream as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeToStream {
    pub fn new() -> SubscribeToStream {
        ::std::default::Default::default()
    }

    // required string event_stream_id = 1;


    pub fn get_event_stream_id(&self) -> &str {
        match self.event_stream_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_event_stream_id(&mut self) {
        self.event_stream_id = ::std::option::Option::None;
    }

    pub fn has_event_stream_id(&self) -> bool {
        self.event_stream_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stream_id(&mut self, v: ::protobuf::Chars) {
        self.event_stream_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_stream_id(&mut self) -> &mut ::protobuf::Chars {
        if self.event_stream_id.is_none() {
            self.event_stream_id = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.event_stream_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_stream_id(&mut self) -> ::protobuf::Chars {
        self.event_stream_id.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // required bool resolve_link_tos = 2;


    pub fn get_resolve_link_tos(&self) -> bool {
        self.resolve_link_tos.unwrap_or(false)
    }
    pub fn clear_resolve_link_tos(&mut self) {
        self.resolve_link_tos = ::std::option::Option::None;
    }

    pub fn has_resolve_link_tos(&self) -> bool {
        self.resolve_link_tos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resolve_link_tos(&mut self, v: bool) {
        self.resolve_link_tos = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SubscribeToStream {
    fn is_initialized(&self) -> bool {
        if self.event_stream_id.is_none() {
            return false;
        }
        if self.resolve_link_tos.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.event_stream_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.resolve_link_tos = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.event_stream_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.resolve_link_tos {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.event_stream_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.resolve_link_tos {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeToStream {
        SubscribeToStream::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "event_stream_id",
                    |m: &SubscribeToStream| { &m.event_stream_id },
                    |m: &mut SubscribeToStream| { &mut m.event_stream_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "resolve_link_tos",
                    |m: &SubscribeToStream| { &m.resolve_link_tos },
                    |m: &mut SubscribeToStream| { &mut m.resolve_link_tos },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeToStream>(
                    "SubscribeToStream",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeToStream {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeToStream> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeToStream,
        };
        unsafe {
            instance.get(SubscribeToStream::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeToStream {
    fn clear(&mut self) {
        self.event_stream_id = ::std::option::Option::None;
        self.resolve_link_tos = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeToStream {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeToStream {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscriptionConfirmation {
    // message fields
    last_commit_position: ::std::option::Option<i64>,
    last_event_number: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscriptionConfirmation {
    fn default() -> &'a SubscriptionConfirmation {
        <SubscriptionConfirmation as ::protobuf::Message>::default_instance()
    }
}

impl SubscriptionConfirmation {
    pub fn new() -> SubscriptionConfirmation {
        ::std::default::Default::default()
    }

    // required int64 last_commit_position = 1;


    pub fn get_last_commit_position(&self) -> i64 {
        self.last_commit_position.unwrap_or(0)
    }
    pub fn clear_last_commit_position(&mut self) {
        self.last_commit_position = ::std::option::Option::None;
    }

    pub fn has_last_commit_position(&self) -> bool {
        self.last_commit_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_commit_position(&mut self, v: i64) {
        self.last_commit_position = ::std::option::Option::Some(v);
    }

    // optional int64 last_event_number = 2;


    pub fn get_last_event_number(&self) -> i64 {
        self.last_event_number.unwrap_or(0)
    }
    pub fn clear_last_event_number(&mut self) {
        self.last_event_number = ::std::option::Option::None;
    }

    pub fn has_last_event_number(&self) -> bool {
        self.last_event_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_event_number(&mut self, v: i64) {
        self.last_event_number = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SubscriptionConfirmation {
    fn is_initialized(&self) -> bool {
        if self.last_commit_position.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.last_commit_position = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.last_event_number = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.last_commit_position {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_event_number {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.last_commit_position {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.last_event_number {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscriptionConfirmation {
        SubscriptionConfirmation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "last_commit_position",
                    |m: &SubscriptionConfirmation| { &m.last_commit_position },
                    |m: &mut SubscriptionConfirmation| { &mut m.last_commit_position },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "last_event_number",
                    |m: &SubscriptionConfirmation| { &m.last_event_number },
                    |m: &mut SubscriptionConfirmation| { &mut m.last_event_number },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SubscriptionConfirmation>(
                    "SubscriptionConfirmation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscriptionConfirmation {
        static mut instance: ::protobuf::lazy::Lazy<SubscriptionConfirmation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscriptionConfirmation,
        };
        unsafe {
            instance.get(SubscriptionConfirmation::new)
        }
    }
}

impl ::protobuf::Clear for SubscriptionConfirmation {
    fn clear(&mut self) {
        self.last_commit_position = ::std::option::Option::None;
        self.last_event_number = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscriptionConfirmation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscriptionConfirmation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamEventAppeared {
    // message fields
    event: ::protobuf::SingularPtrField<ResolvedEvent>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamEventAppeared {
    fn default() -> &'a StreamEventAppeared {
        <StreamEventAppeared as ::protobuf::Message>::default_instance()
    }
}

impl StreamEventAppeared {
    pub fn new() -> StreamEventAppeared {
        ::std::default::Default::default()
    }

    // required .EventStore.Client.Messages.ResolvedEvent event = 1;


    pub fn get_event(&self) -> &ResolvedEvent {
        self.event.as_ref().unwrap_or_else(|| ResolvedEvent::default_instance())
    }
    pub fn clear_event(&mut self) {
        self.event.clear();
    }

    pub fn has_event(&self) -> bool {
        self.event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event(&mut self, v: ResolvedEvent) {
        self.event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event(&mut self) -> &mut ResolvedEvent {
        if self.event.is_none() {
            self.event.set_default();
        }
        self.event.as_mut().unwrap()
    }

    // Take field
    pub fn take_event(&mut self) -> ResolvedEvent {
        self.event.take().unwrap_or_else(|| ResolvedEvent::new())
    }
}

impl ::protobuf::Message for StreamEventAppeared {
    fn is_initialized(&self) -> bool {
        if self.event.is_none() {
            return false;
        }
        for v in &self.event {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.event)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.event.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamEventAppeared {
        StreamEventAppeared::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResolvedEvent>>(
                    "event",
                    |m: &StreamEventAppeared| { &m.event },
                    |m: &mut StreamEventAppeared| { &mut m.event },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StreamEventAppeared>(
                    "StreamEventAppeared",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StreamEventAppeared {
        static mut instance: ::protobuf::lazy::Lazy<StreamEventAppeared> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StreamEventAppeared,
        };
        unsafe {
            instance.get(StreamEventAppeared::new)
        }
    }
}

impl ::protobuf::Clear for StreamEventAppeared {
    fn clear(&mut self) {
        self.event.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamEventAppeared {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamEventAppeared {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnsubscribeFromStream {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnsubscribeFromStream {
    fn default() -> &'a UnsubscribeFromStream {
        <UnsubscribeFromStream as ::protobuf::Message>::default_instance()
    }
}

impl UnsubscribeFromStream {
    pub fn new() -> UnsubscribeFromStream {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UnsubscribeFromStream {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnsubscribeFromStream {
        UnsubscribeFromStream::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<UnsubscribeFromStream>(
                    "UnsubscribeFromStream",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UnsubscribeFromStream {
        static mut instance: ::protobuf::lazy::Lazy<UnsubscribeFromStream> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UnsubscribeFromStream,
        };
        unsafe {
            instance.get(UnsubscribeFromStream::new)
        }
    }
}

impl ::protobuf::Clear for UnsubscribeFromStream {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnsubscribeFromStream {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnsubscribeFromStream {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscriptionDropped {
    // message fields
    reason: ::std::option::Option<SubscriptionDropped_SubscriptionDropReason>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscriptionDropped {
    fn default() -> &'a SubscriptionDropped {
        <SubscriptionDropped as ::protobuf::Message>::default_instance()
    }
}

impl SubscriptionDropped {
    pub fn new() -> SubscriptionDropped {
        ::std::default::Default::default()
    }

    // optional .EventStore.Client.Messages.SubscriptionDropped.SubscriptionDropReason reason = 1;


    pub fn get_reason(&self) -> SubscriptionDropped_SubscriptionDropReason {
        self.reason.unwrap_or(SubscriptionDropped_SubscriptionDropReason::Unsubscribed)
    }
    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: SubscriptionDropped_SubscriptionDropReason) {
        self.reason = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SubscriptionDropped {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.reason, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.reason {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscriptionDropped {
        SubscriptionDropped::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SubscriptionDropped_SubscriptionDropReason>>(
                    "reason",
                    |m: &SubscriptionDropped| { &m.reason },
                    |m: &mut SubscriptionDropped| { &mut m.reason },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SubscriptionDropped>(
                    "SubscriptionDropped",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscriptionDropped {
        static mut instance: ::protobuf::lazy::Lazy<SubscriptionDropped> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscriptionDropped,
        };
        unsafe {
            instance.get(SubscriptionDropped::new)
        }
    }
}

impl ::protobuf::Clear for SubscriptionDropped {
    fn clear(&mut self) {
        self.reason = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscriptionDropped {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscriptionDropped {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SubscriptionDropped_SubscriptionDropReason {
    Unsubscribed = 0,
    AccessDenied = 1,
    NotFound = 2,
    PersistentSubscriptionDeleted = 3,
    SubscriberMaxCountReached = 4,
}

impl ::protobuf::ProtobufEnum for SubscriptionDropped_SubscriptionDropReason {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SubscriptionDropped_SubscriptionDropReason> {
        match value {
            0 => ::std::option::Option::Some(SubscriptionDropped_SubscriptionDropReason::Unsubscribed),
            1 => ::std::option::Option::Some(SubscriptionDropped_SubscriptionDropReason::AccessDenied),
            2 => ::std::option::Option::Some(SubscriptionDropped_SubscriptionDropReason::NotFound),
            3 => ::std::option::Option::Some(SubscriptionDropped_SubscriptionDropReason::PersistentSubscriptionDeleted),
            4 => ::std::option::Option::Some(SubscriptionDropped_SubscriptionDropReason::SubscriberMaxCountReached),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SubscriptionDropped_SubscriptionDropReason] = &[
            SubscriptionDropped_SubscriptionDropReason::Unsubscribed,
            SubscriptionDropped_SubscriptionDropReason::AccessDenied,
            SubscriptionDropped_SubscriptionDropReason::NotFound,
            SubscriptionDropped_SubscriptionDropReason::PersistentSubscriptionDeleted,
            SubscriptionDropped_SubscriptionDropReason::SubscriberMaxCountReached,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SubscriptionDropped_SubscriptionDropReason", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SubscriptionDropped_SubscriptionDropReason {
}

impl ::std::default::Default for SubscriptionDropped_SubscriptionDropReason {
    fn default() -> Self {
        SubscriptionDropped_SubscriptionDropReason::Unsubscribed
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscriptionDropped_SubscriptionDropReason {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NotHandled {
    // message fields
    reason: ::std::option::Option<NotHandled_NotHandledReason>,
    additional_info: ::std::option::Option<::bytes::Bytes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NotHandled {
    fn default() -> &'a NotHandled {
        <NotHandled as ::protobuf::Message>::default_instance()
    }
}

impl NotHandled {
    pub fn new() -> NotHandled {
        ::std::default::Default::default()
    }

    // required .EventStore.Client.Messages.NotHandled.NotHandledReason reason = 1;


    pub fn get_reason(&self) -> NotHandled_NotHandledReason {
        self.reason.unwrap_or(NotHandled_NotHandledReason::NotReady)
    }
    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: NotHandled_NotHandledReason) {
        self.reason = ::std::option::Option::Some(v);
    }

    // optional bytes additional_info = 2;


    pub fn get_additional_info(&self) -> &[u8] {
        match self.additional_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
    pub fn clear_additional_info(&mut self) {
        self.additional_info = ::std::option::Option::None;
    }

    pub fn has_additional_info(&self) -> bool {
        self.additional_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_info(&mut self, v: ::bytes::Bytes) {
        self.additional_info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_additional_info(&mut self) -> &mut ::bytes::Bytes {
        if self.additional_info.is_none() {
            self.additional_info = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.additional_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_additional_info(&mut self) -> ::bytes::Bytes {
        self.additional_info.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }
}

impl ::protobuf::Message for NotHandled {
    fn is_initialized(&self) -> bool {
        if self.reason.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.reason, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_carllerche_bytes_into(wire_type, is, &mut self.additional_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.additional_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.reason {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.additional_info.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NotHandled {
        NotHandled::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NotHandled_NotHandledReason>>(
                    "reason",
                    |m: &NotHandled| { &m.reason },
                    |m: &mut NotHandled| { &mut m.reason },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "additional_info",
                    |m: &NotHandled| { &m.additional_info },
                    |m: &mut NotHandled| { &mut m.additional_info },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NotHandled>(
                    "NotHandled",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NotHandled {
        static mut instance: ::protobuf::lazy::Lazy<NotHandled> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NotHandled,
        };
        unsafe {
            instance.get(NotHandled::new)
        }
    }
}

impl ::protobuf::Clear for NotHandled {
    fn clear(&mut self) {
        self.reason = ::std::option::Option::None;
        self.additional_info = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NotHandled {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NotHandled {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NotHandled_MasterInfo {
    // message fields
    external_tcp_address: ::std::option::Option<::protobuf::Chars>,
    external_tcp_port: ::std::option::Option<i32>,
    external_http_address: ::std::option::Option<::protobuf::Chars>,
    external_http_port: ::std::option::Option<i32>,
    external_secure_tcp_address: ::std::option::Option<::protobuf::Chars>,
    external_secure_tcp_port: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NotHandled_MasterInfo {
    fn default() -> &'a NotHandled_MasterInfo {
        <NotHandled_MasterInfo as ::protobuf::Message>::default_instance()
    }
}

impl NotHandled_MasterInfo {
    pub fn new() -> NotHandled_MasterInfo {
        ::std::default::Default::default()
    }

    // required string external_tcp_address = 1;


    pub fn get_external_tcp_address(&self) -> &str {
        match self.external_tcp_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_external_tcp_address(&mut self) {
        self.external_tcp_address = ::std::option::Option::None;
    }

    pub fn has_external_tcp_address(&self) -> bool {
        self.external_tcp_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_external_tcp_address(&mut self, v: ::protobuf::Chars) {
        self.external_tcp_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_external_tcp_address(&mut self) -> &mut ::protobuf::Chars {
        if self.external_tcp_address.is_none() {
            self.external_tcp_address = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.external_tcp_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_external_tcp_address(&mut self) -> ::protobuf::Chars {
        self.external_tcp_address.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // required int32 external_tcp_port = 2;


    pub fn get_external_tcp_port(&self) -> i32 {
        self.external_tcp_port.unwrap_or(0)
    }
    pub fn clear_external_tcp_port(&mut self) {
        self.external_tcp_port = ::std::option::Option::None;
    }

    pub fn has_external_tcp_port(&self) -> bool {
        self.external_tcp_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_external_tcp_port(&mut self, v: i32) {
        self.external_tcp_port = ::std::option::Option::Some(v);
    }

    // required string external_http_address = 3;


    pub fn get_external_http_address(&self) -> &str {
        match self.external_http_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_external_http_address(&mut self) {
        self.external_http_address = ::std::option::Option::None;
    }

    pub fn has_external_http_address(&self) -> bool {
        self.external_http_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_external_http_address(&mut self, v: ::protobuf::Chars) {
        self.external_http_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_external_http_address(&mut self) -> &mut ::protobuf::Chars {
        if self.external_http_address.is_none() {
            self.external_http_address = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.external_http_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_external_http_address(&mut self) -> ::protobuf::Chars {
        self.external_http_address.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // required int32 external_http_port = 4;


    pub fn get_external_http_port(&self) -> i32 {
        self.external_http_port.unwrap_or(0)
    }
    pub fn clear_external_http_port(&mut self) {
        self.external_http_port = ::std::option::Option::None;
    }

    pub fn has_external_http_port(&self) -> bool {
        self.external_http_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_external_http_port(&mut self, v: i32) {
        self.external_http_port = ::std::option::Option::Some(v);
    }

    // optional string external_secure_tcp_address = 5;


    pub fn get_external_secure_tcp_address(&self) -> &str {
        match self.external_secure_tcp_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_external_secure_tcp_address(&mut self) {
        self.external_secure_tcp_address = ::std::option::Option::None;
    }

    pub fn has_external_secure_tcp_address(&self) -> bool {
        self.external_secure_tcp_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_external_secure_tcp_address(&mut self, v: ::protobuf::Chars) {
        self.external_secure_tcp_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_external_secure_tcp_address(&mut self) -> &mut ::protobuf::Chars {
        if self.external_secure_tcp_address.is_none() {
            self.external_secure_tcp_address = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.external_secure_tcp_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_external_secure_tcp_address(&mut self) -> ::protobuf::Chars {
        self.external_secure_tcp_address.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional int32 external_secure_tcp_port = 6;


    pub fn get_external_secure_tcp_port(&self) -> i32 {
        self.external_secure_tcp_port.unwrap_or(0)
    }
    pub fn clear_external_secure_tcp_port(&mut self) {
        self.external_secure_tcp_port = ::std::option::Option::None;
    }

    pub fn has_external_secure_tcp_port(&self) -> bool {
        self.external_secure_tcp_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_external_secure_tcp_port(&mut self, v: i32) {
        self.external_secure_tcp_port = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for NotHandled_MasterInfo {
    fn is_initialized(&self) -> bool {
        if self.external_tcp_address.is_none() {
            return false;
        }
        if self.external_tcp_port.is_none() {
            return false;
        }
        if self.external_http_address.is_none() {
            return false;
        }
        if self.external_http_port.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.external_tcp_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.external_tcp_port = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.external_http_address)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.external_http_port = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.external_secure_tcp_address)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.external_secure_tcp_port = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.external_tcp_address.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.external_tcp_port {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.external_http_address.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.external_http_port {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.external_secure_tcp_address.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.external_secure_tcp_port {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.external_tcp_address.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.external_tcp_port {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.external_http_address.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.external_http_port {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.external_secure_tcp_address.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.external_secure_tcp_port {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NotHandled_MasterInfo {
        NotHandled_MasterInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "external_tcp_address",
                    |m: &NotHandled_MasterInfo| { &m.external_tcp_address },
                    |m: &mut NotHandled_MasterInfo| { &mut m.external_tcp_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "external_tcp_port",
                    |m: &NotHandled_MasterInfo| { &m.external_tcp_port },
                    |m: &mut NotHandled_MasterInfo| { &mut m.external_tcp_port },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "external_http_address",
                    |m: &NotHandled_MasterInfo| { &m.external_http_address },
                    |m: &mut NotHandled_MasterInfo| { &mut m.external_http_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "external_http_port",
                    |m: &NotHandled_MasterInfo| { &m.external_http_port },
                    |m: &mut NotHandled_MasterInfo| { &mut m.external_http_port },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "external_secure_tcp_address",
                    |m: &NotHandled_MasterInfo| { &m.external_secure_tcp_address },
                    |m: &mut NotHandled_MasterInfo| { &mut m.external_secure_tcp_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "external_secure_tcp_port",
                    |m: &NotHandled_MasterInfo| { &m.external_secure_tcp_port },
                    |m: &mut NotHandled_MasterInfo| { &mut m.external_secure_tcp_port },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NotHandled_MasterInfo>(
                    "NotHandled_MasterInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NotHandled_MasterInfo {
        static mut instance: ::protobuf::lazy::Lazy<NotHandled_MasterInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NotHandled_MasterInfo,
        };
        unsafe {
            instance.get(NotHandled_MasterInfo::new)
        }
    }
}

impl ::protobuf::Clear for NotHandled_MasterInfo {
    fn clear(&mut self) {
        self.external_tcp_address = ::std::option::Option::None;
        self.external_tcp_port = ::std::option::Option::None;
        self.external_http_address = ::std::option::Option::None;
        self.external_http_port = ::std::option::Option::None;
        self.external_secure_tcp_address = ::std::option::Option::None;
        self.external_secure_tcp_port = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NotHandled_MasterInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NotHandled_MasterInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NotHandled_NotHandledReason {
    NotReady = 0,
    TooBusy = 1,
    NotMaster = 2,
}

impl ::protobuf::ProtobufEnum for NotHandled_NotHandledReason {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NotHandled_NotHandledReason> {
        match value {
            0 => ::std::option::Option::Some(NotHandled_NotHandledReason::NotReady),
            1 => ::std::option::Option::Some(NotHandled_NotHandledReason::TooBusy),
            2 => ::std::option::Option::Some(NotHandled_NotHandledReason::NotMaster),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NotHandled_NotHandledReason] = &[
            NotHandled_NotHandledReason::NotReady,
            NotHandled_NotHandledReason::TooBusy,
            NotHandled_NotHandledReason::NotMaster,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("NotHandled_NotHandledReason", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for NotHandled_NotHandledReason {
}

impl ::std::default::Default for NotHandled_NotHandledReason {
    fn default() -> Self {
        NotHandled_NotHandledReason::NotReady
    }
}

impl ::protobuf::reflect::ProtobufValue for NotHandled_NotHandledReason {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScavengeDatabase {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScavengeDatabase {
    fn default() -> &'a ScavengeDatabase {
        <ScavengeDatabase as ::protobuf::Message>::default_instance()
    }
}

impl ScavengeDatabase {
    pub fn new() -> ScavengeDatabase {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ScavengeDatabase {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScavengeDatabase {
        ScavengeDatabase::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ScavengeDatabase>(
                    "ScavengeDatabase",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ScavengeDatabase {
        static mut instance: ::protobuf::lazy::Lazy<ScavengeDatabase> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ScavengeDatabase,
        };
        unsafe {
            instance.get(ScavengeDatabase::new)
        }
    }
}

impl ::protobuf::Clear for ScavengeDatabase {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScavengeDatabase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScavengeDatabase {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScavengeDatabaseCompleted {
    // message fields
    result: ::std::option::Option<ScavengeDatabaseCompleted_ScavengeResult>,
    error: ::std::option::Option<::protobuf::Chars>,
    total_time_ms: ::std::option::Option<i32>,
    total_space_saved: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScavengeDatabaseCompleted {
    fn default() -> &'a ScavengeDatabaseCompleted {
        <ScavengeDatabaseCompleted as ::protobuf::Message>::default_instance()
    }
}

impl ScavengeDatabaseCompleted {
    pub fn new() -> ScavengeDatabaseCompleted {
        ::std::default::Default::default()
    }

    // required .EventStore.Client.Messages.ScavengeDatabaseCompleted.ScavengeResult result = 1;


    pub fn get_result(&self) -> ScavengeDatabaseCompleted_ScavengeResult {
        self.result.unwrap_or(ScavengeDatabaseCompleted_ScavengeResult::Success)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ScavengeDatabaseCompleted_ScavengeResult) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional string error = 2;


    pub fn get_error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::protobuf::Chars) {
        self.error = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::protobuf::Chars {
        if self.error.is_none() {
            self.error = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::protobuf::Chars {
        self.error.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // required int32 total_time_ms = 3;


    pub fn get_total_time_ms(&self) -> i32 {
        self.total_time_ms.unwrap_or(0)
    }
    pub fn clear_total_time_ms(&mut self) {
        self.total_time_ms = ::std::option::Option::None;
    }

    pub fn has_total_time_ms(&self) -> bool {
        self.total_time_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_time_ms(&mut self, v: i32) {
        self.total_time_ms = ::std::option::Option::Some(v);
    }

    // required int64 total_space_saved = 4;


    pub fn get_total_space_saved(&self) -> i64 {
        self.total_space_saved.unwrap_or(0)
    }
    pub fn clear_total_space_saved(&mut self) {
        self.total_space_saved = ::std::option::Option::None;
    }

    pub fn has_total_space_saved(&self) -> bool {
        self.total_space_saved.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_space_saved(&mut self, v: i64) {
        self.total_space_saved = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ScavengeDatabaseCompleted {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        if self.total_time_ms.is_none() {
            return false;
        }
        if self.total_space_saved.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.total_time_ms = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_space_saved = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.total_time_ms {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_space_saved {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.total_time_ms {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.total_space_saved {
            os.write_int64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScavengeDatabaseCompleted {
        ScavengeDatabaseCompleted::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ScavengeDatabaseCompleted_ScavengeResult>>(
                    "result",
                    |m: &ScavengeDatabaseCompleted| { &m.result },
                    |m: &mut ScavengeDatabaseCompleted| { &mut m.result },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "error",
                    |m: &ScavengeDatabaseCompleted| { &m.error },
                    |m: &mut ScavengeDatabaseCompleted| { &mut m.error },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "total_time_ms",
                    |m: &ScavengeDatabaseCompleted| { &m.total_time_ms },
                    |m: &mut ScavengeDatabaseCompleted| { &mut m.total_time_ms },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_space_saved",
                    |m: &ScavengeDatabaseCompleted| { &m.total_space_saved },
                    |m: &mut ScavengeDatabaseCompleted| { &mut m.total_space_saved },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ScavengeDatabaseCompleted>(
                    "ScavengeDatabaseCompleted",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ScavengeDatabaseCompleted {
        static mut instance: ::protobuf::lazy::Lazy<ScavengeDatabaseCompleted> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ScavengeDatabaseCompleted,
        };
        unsafe {
            instance.get(ScavengeDatabaseCompleted::new)
        }
    }
}

impl ::protobuf::Clear for ScavengeDatabaseCompleted {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.total_time_ms = ::std::option::Option::None;
        self.total_space_saved = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScavengeDatabaseCompleted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScavengeDatabaseCompleted {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ScavengeDatabaseCompleted_ScavengeResult {
    Success = 0,
    InProgress = 1,
    Failed = 2,
}

impl ::protobuf::ProtobufEnum for ScavengeDatabaseCompleted_ScavengeResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ScavengeDatabaseCompleted_ScavengeResult> {
        match value {
            0 => ::std::option::Option::Some(ScavengeDatabaseCompleted_ScavengeResult::Success),
            1 => ::std::option::Option::Some(ScavengeDatabaseCompleted_ScavengeResult::InProgress),
            2 => ::std::option::Option::Some(ScavengeDatabaseCompleted_ScavengeResult::Failed),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ScavengeDatabaseCompleted_ScavengeResult] = &[
            ScavengeDatabaseCompleted_ScavengeResult::Success,
            ScavengeDatabaseCompleted_ScavengeResult::InProgress,
            ScavengeDatabaseCompleted_ScavengeResult::Failed,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ScavengeDatabaseCompleted_ScavengeResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ScavengeDatabaseCompleted_ScavengeResult {
}

impl ::std::default::Default for ScavengeDatabaseCompleted_ScavengeResult {
    fn default() -> Self {
        ScavengeDatabaseCompleted_ScavengeResult::Success
    }
}

impl ::protobuf::reflect::ProtobufValue for ScavengeDatabaseCompleted_ScavengeResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IdentifyClient {
    // message fields
    version: ::std::option::Option<i32>,
    connection_name: ::std::option::Option<::protobuf::Chars>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IdentifyClient {
    fn default() -> &'a IdentifyClient {
        <IdentifyClient as ::protobuf::Message>::default_instance()
    }
}

impl IdentifyClient {
    pub fn new() -> IdentifyClient {
        ::std::default::Default::default()
    }

    // required int32 version = 1;


    pub fn get_version(&self) -> i32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional string connection_name = 2;


    pub fn get_connection_name(&self) -> &str {
        match self.connection_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_connection_name(&mut self) {
        self.connection_name = ::std::option::Option::None;
    }

    pub fn has_connection_name(&self) -> bool {
        self.connection_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_name(&mut self, v: ::protobuf::Chars) {
        self.connection_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connection_name(&mut self) -> &mut ::protobuf::Chars {
        if self.connection_name.is_none() {
            self.connection_name = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.connection_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_connection_name(&mut self) -> ::protobuf::Chars {
        self.connection_name.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for IdentifyClient {
    fn is_initialized(&self) -> bool {
        if self.version.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.connection_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.connection_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.connection_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IdentifyClient {
        IdentifyClient::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "version",
                    |m: &IdentifyClient| { &m.version },
                    |m: &mut IdentifyClient| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "connection_name",
                    |m: &IdentifyClient| { &m.connection_name },
                    |m: &mut IdentifyClient| { &mut m.connection_name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IdentifyClient>(
                    "IdentifyClient",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IdentifyClient {
        static mut instance: ::protobuf::lazy::Lazy<IdentifyClient> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IdentifyClient,
        };
        unsafe {
            instance.get(IdentifyClient::new)
        }
    }
}

impl ::protobuf::Clear for IdentifyClient {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.connection_name = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IdentifyClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IdentifyClient {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClientIdentified {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientIdentified {
    fn default() -> &'a ClientIdentified {
        <ClientIdentified as ::protobuf::Message>::default_instance()
    }
}

impl ClientIdentified {
    pub fn new() -> ClientIdentified {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ClientIdentified {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientIdentified {
        ClientIdentified::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ClientIdentified>(
                    "ClientIdentified",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ClientIdentified {
        static mut instance: ::protobuf::lazy::Lazy<ClientIdentified> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClientIdentified,
        };
        unsafe {
            instance.get(ClientIdentified::new)
        }
    }
}

impl ::protobuf::Clear for ClientIdentified {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientIdentified {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientIdentified {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OperationResult {
    Success = 0,
    PrepareTimeout = 1,
    CommitTimeout = 2,
    ForwardTimeout = 3,
    WrongExpectedVersion = 4,
    StreamDeleted = 5,
    InvalidTransaction = 6,
    AccessDenied = 7,
}

impl ::protobuf::ProtobufEnum for OperationResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OperationResult> {
        match value {
            0 => ::std::option::Option::Some(OperationResult::Success),
            1 => ::std::option::Option::Some(OperationResult::PrepareTimeout),
            2 => ::std::option::Option::Some(OperationResult::CommitTimeout),
            3 => ::std::option::Option::Some(OperationResult::ForwardTimeout),
            4 => ::std::option::Option::Some(OperationResult::WrongExpectedVersion),
            5 => ::std::option::Option::Some(OperationResult::StreamDeleted),
            6 => ::std::option::Option::Some(OperationResult::InvalidTransaction),
            7 => ::std::option::Option::Some(OperationResult::AccessDenied),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OperationResult] = &[
            OperationResult::Success,
            OperationResult::PrepareTimeout,
            OperationResult::CommitTimeout,
            OperationResult::ForwardTimeout,
            OperationResult::WrongExpectedVersion,
            OperationResult::StreamDeleted,
            OperationResult::InvalidTransaction,
            OperationResult::AccessDenied,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("OperationResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for OperationResult {
}

impl ::std::default::Default for OperationResult {
    fn default() -> Self {
        OperationResult::Success
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0emessages.proto\x12\x1aEventStore.Client.Messages\x1a\x0frustproto.\
    proto\"\xd4\x01\n\x08NewEvent\x12\x19\n\x08event_id\x18\x01\x20\x02(\x0c\
    R\x07eventId\x12\x1d\n\nevent_type\x18\x02\x20\x02(\tR\teventType\x12*\n\
    \x11data_content_type\x18\x03\x20\x02(\x05R\x0fdataContentType\x122\n\
    \x15metadata_content_type\x18\x04\x20\x02(\x05R\x13metadataContentType\
    \x12\x12\n\x04data\x18\x05\x20\x02(\x0cR\x04data\x12\x1a\n\x08metadata\
    \x18\x06\x20\x01(\x0cR\x08metadata\"\xe1\x02\n\x0bEventRecord\x12&\n\x0f\
    event_stream_id\x18\x01\x20\x02(\tR\reventStreamId\x12!\n\x0cevent_numbe\
    r\x18\x02\x20\x02(\x03R\x0beventNumber\x12\x19\n\x08event_id\x18\x03\x20\
    \x02(\x0cR\x07eventId\x12\x1d\n\nevent_type\x18\x04\x20\x02(\tR\teventTy\
    pe\x12*\n\x11data_content_type\x18\x05\x20\x02(\x05R\x0fdataContentType\
    \x122\n\x15metadata_content_type\x18\x06\x20\x02(\x05R\x13metadataConten\
    tType\x12\x12\n\x04data\x18\x07\x20\x02(\x0cR\x04data\x12\x1a\n\x08metad\
    ata\x18\x08\x20\x01(\x0cR\x08metadata\x12\x18\n\x07created\x18\t\x20\x01\
    (\x03R\x07created\x12#\n\rcreated_epoch\x18\n\x20\x01(\x03R\x0ccreatedEp\
    och\"\x92\x01\n\x14ResolvedIndexedEvent\x12=\n\x05event\x18\x01\x20\x01(\
    \x0b2'.EventStore.Client.Messages.EventRecordR\x05event\x12;\n\x04link\
    \x18\x02\x20\x01(\x0b2'.EventStore.Client.Messages.EventRecordR\x04link\
    \"\xdf\x01\n\rResolvedEvent\x12=\n\x05event\x18\x01\x20\x02(\x0b2'.Event\
    Store.Client.Messages.EventRecordR\x05event\x12;\n\x04link\x18\x02\x20\
    \x01(\x0b2'.EventStore.Client.Messages.EventRecordR\x04link\x12'\n\x0fco\
    mmit_position\x18\x03\x20\x02(\x03R\x0ecommitPosition\x12)\n\x10prepare_\
    position\x18\x04\x20\x02(\x03R\x0fpreparePosition\"\xc5\x01\n\x0bWriteEv\
    ents\x12&\n\x0fevent_stream_id\x18\x01\x20\x02(\tR\reventStreamId\x12)\n\
    \x10expected_version\x18\x02\x20\x02(\x03R\x0fexpectedVersion\x12<\n\x06\
    events\x18\x03\x20\x03(\x0b2$.EventStore.Client.Messages.NewEventR\x06ev\
    ents\x12%\n\x0erequire_master\x18\x04\x20\x02(\x08R\rrequireMaster\"\xcc\
    \x02\n\x14WriteEventsCompleted\x12C\n\x06result\x18\x01\x20\x02(\x0e2+.E\
    ventStore.Client.Messages.OperationResultR\x06result\x12\x18\n\x07messag\
    e\x18\x02\x20\x01(\tR\x07message\x12,\n\x12first_event_number\x18\x03\
    \x20\x02(\x03R\x10firstEventNumber\x12*\n\x11last_event_number\x18\x04\
    \x20\x02(\x03R\x0flastEventNumber\x12)\n\x10prepare_position\x18\x05\x20\
    \x01(\x03R\x0fpreparePosition\x12'\n\x0fcommit_position\x18\x06\x20\x01(\
    \x03R\x0ecommitPosition\x12'\n\x0fcurrent_version\x18\x07\x20\x01(\x03R\
    \x0ecurrentVersion\"\xa9\x01\n\x0cDeleteStream\x12&\n\x0fevent_stream_id\
    \x18\x01\x20\x02(\tR\reventStreamId\x12)\n\x10expected_version\x18\x02\
    \x20\x02(\x03R\x0fexpectedVersion\x12%\n\x0erequire_master\x18\x03\x20\
    \x02(\x08R\rrequireMaster\x12\x1f\n\x0bhard_delete\x18\x04\x20\x01(\x08R\
    \nhardDelete\"\xca\x01\n\x15DeleteStreamCompleted\x12C\n\x06result\x18\
    \x01\x20\x02(\x0e2+.EventStore.Client.Messages.OperationResultR\x06resul\
    t\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\x12)\n\x10prepare_\
    position\x18\x03\x20\x01(\x03R\x0fpreparePosition\x12'\n\x0fcommit_posit\
    ion\x18\x04\x20\x01(\x03R\x0ecommitPosition\"\x8c\x01\n\x10TransactionSt\
    art\x12&\n\x0fevent_stream_id\x18\x01\x20\x02(\tR\reventStreamId\x12)\n\
    \x10expected_version\x18\x02\x20\x02(\x03R\x0fexpectedVersion\x12%\n\x0e\
    require_master\x18\x03\x20\x02(\x08R\rrequireMaster\"\xa1\x01\n\x19Trans\
    actionStartCompleted\x12%\n\x0etransaction_id\x18\x01\x20\x02(\x03R\rtra\
    nsactionId\x12C\n\x06result\x18\x02\x20\x02(\x0e2+.EventStore.Client.Mes\
    sages.OperationResultR\x06result\x12\x18\n\x07message\x18\x03\x20\x01(\t\
    R\x07message\"\x9e\x01\n\x10TransactionWrite\x12%\n\x0etransaction_id\
    \x18\x01\x20\x02(\x03R\rtransactionId\x12<\n\x06events\x18\x02\x20\x03(\
    \x0b2$.EventStore.Client.Messages.NewEventR\x06events\x12%\n\x0erequire_\
    master\x18\x03\x20\x02(\x08R\rrequireMaster\"\xa1\x01\n\x19TransactionWr\
    iteCompleted\x12%\n\x0etransaction_id\x18\x01\x20\x02(\x03R\rtransaction\
    Id\x12C\n\x06result\x18\x02\x20\x02(\x0e2+.EventStore.Client.Messages.Op\
    erationResultR\x06result\x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07mes\
    sage\"a\n\x11TransactionCommit\x12%\n\x0etransaction_id\x18\x01\x20\x02(\
    \x03R\rtransactionId\x12%\n\x0erequire_master\x18\x02\x20\x02(\x08R\rreq\
    uireMaster\"\xd0\x02\n\x1aTransactionCommitCompleted\x12%\n\x0etransacti\
    on_id\x18\x01\x20\x02(\x03R\rtransactionId\x12C\n\x06result\x18\x02\x20\
    \x02(\x0e2+.EventStore.Client.Messages.OperationResultR\x06result\x12\
    \x18\n\x07message\x18\x03\x20\x01(\tR\x07message\x12,\n\x12first_event_n\
    umber\x18\x04\x20\x02(\x03R\x10firstEventNumber\x12*\n\x11last_event_num\
    ber\x18\x05\x20\x02(\x03R\x0flastEventNumber\x12)\n\x10prepare_position\
    \x18\x06\x20\x01(\x03R\x0fpreparePosition\x12'\n\x0fcommit_position\x18\
    \x07\x20\x01(\x03R\x0ecommitPosition\"\xa7\x01\n\tReadEvent\x12&\n\x0fev\
    ent_stream_id\x18\x01\x20\x02(\tR\reventStreamId\x12!\n\x0cevent_number\
    \x18\x02\x20\x02(\x03R\x0beventNumber\x12(\n\x10resolve_link_tos\x18\x03\
    \x20\x02(\x08R\x0eresolveLinkTos\x12%\n\x0erequire_master\x18\x04\x20\
    \x02(\x08R\rrequireMaster\"\xb6\x02\n\x12ReadEventCompleted\x12V\n\x06re\
    sult\x18\x01\x20\x02(\x0e2>.EventStore.Client.Messages.ReadEventComplete\
    d.ReadEventResultR\x06result\x12F\n\x05event\x18\x02\x20\x02(\x0b20.Even\
    tStore.Client.Messages.ResolvedIndexedEventR\x05event\x12\x14\n\x05error\
    \x18\x03\x20\x01(\tR\x05error\"j\n\x0fReadEventResult\x12\x0b\n\x07Succe\
    ss\x10\0\x12\x0c\n\x08NotFound\x10\x01\x12\x0c\n\x08NoStream\x10\x02\x12\
    \x11\n\rStreamDeleted\x10\x03\x12\t\n\x05Error\x10\x04\x12\x10\n\x0cAcce\
    ssDenied\x10\x05\"\xd4\x01\n\x10ReadStreamEvents\x12&\n\x0fevent_stream_\
    id\x18\x01\x20\x02(\tR\reventStreamId\x12*\n\x11from_event_number\x18\
    \x02\x20\x02(\x03R\x0ffromEventNumber\x12\x1b\n\tmax_count\x18\x03\x20\
    \x02(\x05R\x08maxCount\x12(\n\x10resolve_link_tos\x18\x04\x20\x02(\x08R\
    \x0eresolveLinkTos\x12%\n\x0erequire_master\x18\x05\x20\x02(\x08R\rrequi\
    reMaster\"\xfe\x03\n\x19ReadStreamEventsCompleted\x12H\n\x06events\x18\
    \x01\x20\x03(\x0b20.EventStore.Client.Messages.ResolvedIndexedEventR\x06\
    events\x12^\n\x06result\x18\x02\x20\x02(\x0e2F.EventStore.Client.Message\
    s.ReadStreamEventsCompleted.ReadStreamResultR\x06result\x12*\n\x11next_e\
    vent_number\x18\x03\x20\x02(\x03R\x0fnextEventNumber\x12*\n\x11last_even\
    t_number\x18\x04\x20\x02(\x03R\x0flastEventNumber\x12'\n\x10is_end_of_st\
    ream\x18\x05\x20\x02(\x08R\risEndOfStream\x120\n\x14last_commit_position\
    \x18\x06\x20\x02(\x03R\x12lastCommitPosition\x12\x14\n\x05error\x18\x07\
    \x20\x01(\tR\x05error\"n\n\x10ReadStreamResult\x12\x0b\n\x07Success\x10\
    \0\x12\x0c\n\x08NoStream\x10\x01\x12\x11\n\rStreamDeleted\x10\x02\x12\
    \x0f\n\x0bNotModified\x10\x03\x12\t\n\x05Error\x10\x04\x12\x10\n\x0cAcce\
    ssDenied\x10\x05\"\xd1\x01\n\rReadAllEvents\x12'\n\x0fcommit_position\
    \x18\x01\x20\x02(\x03R\x0ecommitPosition\x12)\n\x10prepare_position\x18\
    \x02\x20\x02(\x03R\x0fpreparePosition\x12\x1b\n\tmax_count\x18\x03\x20\
    \x02(\x05R\x08maxCount\x12(\n\x10resolve_link_tos\x18\x04\x20\x02(\x08R\
    \x0eresolveLinkTos\x12%\n\x0erequire_master\x18\x05\x20\x02(\x08R\rrequi\
    reMaster\"\xda\x03\n\x16ReadAllEventsCompleted\x12'\n\x0fcommit_position\
    \x18\x01\x20\x02(\x03R\x0ecommitPosition\x12)\n\x10prepare_position\x18\
    \x02\x20\x02(\x03R\x0fpreparePosition\x12A\n\x06events\x18\x03\x20\x03(\
    \x0b2).EventStore.Client.Messages.ResolvedEventR\x06events\x120\n\x14nex\
    t_commit_position\x18\x04\x20\x02(\x03R\x12nextCommitPosition\x122\n\x15\
    next_prepare_position\x18\x05\x20\x02(\x03R\x13nextPreparePosition\x12a\
    \n\x06result\x18\x06\x20\x01(\x0e2@.EventStore.Client.Messages.ReadAllEv\
    entsCompleted.ReadAllResult:\x07SuccessR\x06result\x12\x14\n\x05error\
    \x18\x07\x20\x01(\tR\x05error\"J\n\rReadAllResult\x12\x0b\n\x07Success\
    \x10\0\x12\x0f\n\x0bNotModified\x10\x01\x12\t\n\x05Error\x10\x02\x12\x10\
    \n\x0cAccessDenied\x10\x03\"\x81\x06\n\x1cCreatePersistentSubscription\
    \x126\n\x17subscription_group_name\x18\x01\x20\x02(\tR\x15subscriptionGr\
    oupName\x12&\n\x0fevent_stream_id\x18\x02\x20\x02(\tR\reventStreamId\x12\
    (\n\x10resolve_link_tos\x18\x03\x20\x02(\x08R\x0eresolveLinkTos\x12\x1d\
    \n\nstart_from\x18\x04\x20\x02(\x03R\tstartFrom\x12@\n\x1cmessage_timeou\
    t_milliseconds\x18\x05\x20\x02(\x05R\x1amessageTimeoutMilliseconds\x12+\
    \n\x11record_statistics\x18\x06\x20\x02(\x08R\x10recordStatistics\x12(\n\
    \x10live_buffer_size\x18\x07\x20\x02(\x05R\x0eliveBufferSize\x12&\n\x0fr\
    ead_batch_size\x18\x08\x20\x02(\x05R\rreadBatchSize\x12\x1f\n\x0bbuffer_\
    size\x18\t\x20\x02(\x05R\nbufferSize\x12&\n\x0fmax_retry_count\x18\n\x20\
    \x02(\x05R\rmaxRetryCount\x12,\n\x12prefer_round_robin\x18\x0b\x20\x02(\
    \x08R\x10preferRoundRobin\x122\n\x15checkpoint_after_time\x18\x0c\x20\
    \x02(\x05R\x13checkpointAfterTime\x120\n\x14checkpoint_max_count\x18\r\
    \x20\x02(\x05R\x12checkpointMaxCount\x120\n\x14checkpoint_min_count\x18\
    \x0e\x20\x02(\x05R\x12checkpointMinCount\x120\n\x14subscriber_max_count\
    \x18\x0f\x20\x02(\x05R\x12subscriberMaxCount\x126\n\x17named_consumer_st\
    rategy\x18\x10\x20\x01(\tR\x15namedConsumerStrategy\"~\n\x1cDeletePersis\
    tentSubscription\x126\n\x17subscription_group_name\x18\x01\x20\x02(\tR\
    \x15subscriptionGroupName\x12&\n\x0fevent_stream_id\x18\x02\x20\x02(\tR\
    \reventStreamId\"\x81\x06\n\x1cUpdatePersistentSubscription\x126\n\x17su\
    bscription_group_name\x18\x01\x20\x02(\tR\x15subscriptionGroupName\x12&\
    \n\x0fevent_stream_id\x18\x02\x20\x02(\tR\reventStreamId\x12(\n\x10resol\
    ve_link_tos\x18\x03\x20\x02(\x08R\x0eresolveLinkTos\x12\x1d\n\nstart_fro\
    m\x18\x04\x20\x02(\x03R\tstartFrom\x12@\n\x1cmessage_timeout_millisecond\
    s\x18\x05\x20\x02(\x05R\x1amessageTimeoutMilliseconds\x12+\n\x11record_s\
    tatistics\x18\x06\x20\x02(\x08R\x10recordStatistics\x12(\n\x10live_buffe\
    r_size\x18\x07\x20\x02(\x05R\x0eliveBufferSize\x12&\n\x0fread_batch_size\
    \x18\x08\x20\x02(\x05R\rreadBatchSize\x12\x1f\n\x0bbuffer_size\x18\t\x20\
    \x02(\x05R\nbufferSize\x12&\n\x0fmax_retry_count\x18\n\x20\x02(\x05R\rma\
    xRetryCount\x12,\n\x12prefer_round_robin\x18\x0b\x20\x02(\x08R\x10prefer\
    RoundRobin\x122\n\x15checkpoint_after_time\x18\x0c\x20\x02(\x05R\x13chec\
    kpointAfterTime\x120\n\x14checkpoint_max_count\x18\r\x20\x02(\x05R\x12ch\
    eckpointMaxCount\x120\n\x14checkpoint_min_count\x18\x0e\x20\x02(\x05R\
    \x12checkpointMinCount\x120\n\x14subscriber_max_count\x18\x0f\x20\x02(\
    \x05R\x12subscriberMaxCount\x126\n\x17named_consumer_strategy\x18\x10\
    \x20\x01(\tR\x15namedConsumerStrategy\"\xa8\x02\n%UpdatePersistentSubscr\
    iptionCompleted\x12\x85\x01\n\x06result\x18\x01\x20\x02(\x0e2d.EventStor\
    e.Client.Messages.UpdatePersistentSubscriptionCompleted.UpdatePersistent\
    SubscriptionResult:\x07SuccessR\x06result\x12\x16\n\x06reason\x18\x02\
    \x20\x01(\tR\x06reason\"_\n\"UpdatePersistentSubscriptionResult\x12\x0b\
    \n\x07Success\x10\0\x12\x10\n\x0cDoesNotExist\x10\x01\x12\x08\n\x04Fail\
    \x10\x02\x12\x10\n\x0cAccessDenied\x10\x03\"\xa9\x02\n%CreatePersistentS\
    ubscriptionCompleted\x12\x85\x01\n\x06result\x18\x01\x20\x02(\x0e2d.Even\
    tStore.Client.Messages.CreatePersistentSubscriptionCompleted.CreatePersi\
    stentSubscriptionResult:\x07SuccessR\x06result\x12\x16\n\x06reason\x18\
    \x02\x20\x01(\tR\x06reason\"`\n\"CreatePersistentSubscriptionResult\x12\
    \x0b\n\x07Success\x10\0\x12\x11\n\rAlreadyExists\x10\x01\x12\x08\n\x04Fa\
    il\x10\x02\x12\x10\n\x0cAccessDenied\x10\x03\"\xa8\x02\n%DeletePersisten\
    tSubscriptionCompleted\x12\x85\x01\n\x06result\x18\x01\x20\x02(\x0e2d.Ev\
    entStore.Client.Messages.DeletePersistentSubscriptionCompleted.DeletePer\
    sistentSubscriptionResult:\x07SuccessR\x06result\x12\x16\n\x06reason\x18\
    \x02\x20\x01(\tR\x06reason\"_\n\"DeletePersistentSubscriptionResult\x12\
    \x0b\n\x07Success\x10\0\x12\x10\n\x0cDoesNotExist\x10\x01\x12\x08\n\x04F\
    ail\x10\x02\x12\x10\n\x0cAccessDenied\x10\x03\"\xaf\x01\n\x1fConnectToPe\
    rsistentSubscription\x12'\n\x0fsubscription_id\x18\x01\x20\x02(\tR\x0esu\
    bscriptionId\x12&\n\x0fevent_stream_id\x18\x02\x20\x02(\tR\reventStreamI\
    d\x12;\n\x1aallowed_in_flight_messages\x18\x03\x20\x02(\x05R\x17allowedI\
    nFlightMessages\"z\n\x1fPersistentSubscriptionAckEvents\x12'\n\x0fsubscr\
    iption_id\x18\x01\x20\x02(\tR\x0esubscriptionId\x12.\n\x13processed_even\
    t_ids\x18\x02\x20\x03(\x0cR\x11processedEventIds\"\xbf\x02\n\x1fPersiste\
    ntSubscriptionNakEvents\x12'\n\x0fsubscription_id\x18\x01\x20\x02(\tR\
    \x0esubscriptionId\x12.\n\x13processed_event_ids\x18\x02\x20\x03(\x0cR\
    \x11processedEventIds\x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07messag\
    e\x12f\n\x06action\x18\x04\x20\x02(\x0e2E.EventStore.Client.Messages.Per\
    sistentSubscriptionNakEvents.NakAction:\x07UnknownR\x06action\"A\n\tNakA\
    ction\x12\x0b\n\x07Unknown\x10\0\x12\x08\n\x04Park\x10\x01\x12\t\n\x05Re\
    try\x10\x02\x12\x08\n\x04Skip\x10\x03\x12\x08\n\x04Stop\x10\x04\"\xab\
    \x01\n\"PersistentSubscriptionConfirmation\x120\n\x14last_commit_positio\
    n\x18\x01\x20\x02(\x03R\x12lastCommitPosition\x12'\n\x0fsubscription_id\
    \x18\x02\x20\x02(\tR\x0esubscriptionId\x12*\n\x11last_event_number\x18\
    \x03\x20\x01(\x03R\x0flastEventNumber\"\x93\x01\n)PersistentSubscription\
    StreamEventAppeared\x12F\n\x05event\x18\x01\x20\x02(\x0b20.EventStore.Cl\
    ient.Messages.ResolvedIndexedEventR\x05event\x12\x1e\n\nretryCount\x18\
    \x02\x20\x01(\x05R\nretryCount\"e\n\x11SubscribeToStream\x12&\n\x0fevent\
    _stream_id\x18\x01\x20\x02(\tR\reventStreamId\x12(\n\x10resolve_link_tos\
    \x18\x02\x20\x02(\x08R\x0eresolveLinkTos\"x\n\x18SubscriptionConfirmatio\
    n\x120\n\x14last_commit_position\x18\x01\x20\x02(\x03R\x12lastCommitPosi\
    tion\x12*\n\x11last_event_number\x18\x02\x20\x01(\x03R\x0flastEventNumbe\
    r\"V\n\x13StreamEventAppeared\x12?\n\x05event\x18\x01\x20\x02(\x0b2).Eve\
    ntStore.Client.Messages.ResolvedEventR\x05event\"\x17\n\x15UnsubscribeFr\
    omStream\"\x92\x02\n\x13SubscriptionDropped\x12l\n\x06reason\x18\x01\x20\
    \x01(\x0e2F.EventStore.Client.Messages.SubscriptionDropped.SubscriptionD\
    ropReason:\x0cUnsubscribedR\x06reason\"\x8c\x01\n\x16SubscriptionDropRea\
    son\x12\x10\n\x0cUnsubscribed\x10\0\x12\x10\n\x0cAccessDenied\x10\x01\
    \x12\x0c\n\x08NotFound\x10\x02\x12!\n\x1dPersistentSubscriptionDeleted\
    \x10\x03\x12\x1d\n\x19SubscriberMaxCountReached\x10\x04\"\x8b\x04\n\nNot\
    Handled\x12O\n\x06reason\x18\x01\x20\x02(\x0e27.EventStore.Client.Messag\
    es.NotHandled.NotHandledReasonR\x06reason\x12'\n\x0fadditional_info\x18\
    \x02\x20\x01(\x0cR\x0eadditionalInfo\x1a\xc4\x02\n\nMasterInfo\x120\n\
    \x14external_tcp_address\x18\x01\x20\x02(\tR\x12externalTcpAddress\x12*\
    \n\x11external_tcp_port\x18\x02\x20\x02(\x05R\x0fexternalTcpPort\x122\n\
    \x15external_http_address\x18\x03\x20\x02(\tR\x13externalHttpAddress\x12\
    ,\n\x12external_http_port\x18\x04\x20\x02(\x05R\x10externalHttpPort\x12=\
    \n\x1bexternal_secure_tcp_address\x18\x05\x20\x01(\tR\x18externalSecureT\
    cpAddress\x127\n\x18external_secure_tcp_port\x18\x06\x20\x01(\x05R\x15ex\
    ternalSecureTcpPort\"<\n\x10NotHandledReason\x12\x0c\n\x08NotReady\x10\0\
    \x12\x0b\n\x07TooBusy\x10\x01\x12\r\n\tNotMaster\x10\x02\"\x12\n\x10Scav\
    engeDatabase\"\x9a\x02\n\x19ScavengeDatabaseCompleted\x12\\\n\x06result\
    \x18\x01\x20\x02(\x0e2D.EventStore.Client.Messages.ScavengeDatabaseCompl\
    eted.ScavengeResultR\x06result\x12\x14\n\x05error\x18\x02\x20\x01(\tR\
    \x05error\x12\"\n\rtotal_time_ms\x18\x03\x20\x02(\x05R\x0btotalTimeMs\
    \x12*\n\x11total_space_saved\x18\x04\x20\x02(\x03R\x0ftotalSpaceSaved\"9\
    \n\x0eScavengeResult\x12\x0b\n\x07Success\x10\0\x12\x0e\n\nInProgress\
    \x10\x01\x12\n\n\x06Failed\x10\x02\"S\n\x0eIdentifyClient\x12\x18\n\x07v\
    ersion\x18\x01\x20\x02(\x05R\x07version\x12'\n\x0fconnection_name\x18\
    \x02\x20\x01(\tR\x0econnectionName\"\x12\n\x10ClientIdentified*\xb0\x01\
    \n\x0fOperationResult\x12\x0b\n\x07Success\x10\0\x12\x12\n\x0ePrepareTim\
    eout\x10\x01\x12\x11\n\rCommitTimeout\x10\x02\x12\x12\n\x0eForwardTimeou\
    t\x10\x03\x12\x18\n\x14WrongExpectedVersion\x10\x04\x12\x11\n\rStreamDel\
    eted\x10\x05\x12\x16\n\x12InvalidTransaction\x10\x06\x12\x10\n\x0cAccess\
    Denied\x10\x07\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
